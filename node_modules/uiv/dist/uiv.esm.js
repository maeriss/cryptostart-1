import Vue from 'vue';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
function assign (target, varArgs) {
  var arguments$1 = arguments;

  if (target === null || target === undefined) {
    throw new TypeError('Cannot convert undefined or null to object')
  }
  var to = Object(target);
  for (var index = 1; index < arguments.length; index++) {
    var nextSource = arguments$1[index];
    if (nextSource !== null && nextSource !== undefined) {
      for (var nextKey in nextSource) {
        // Avoid bugs when hasOwnProperty is shadowed
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }
  return to
}

function isExist (obj) {
  return typeof obj !== 'undefined' && obj !== null
}

function isFunction (obj) {
  return typeof obj === 'function'
}

function isNumber (obj) {
  return typeof obj === 'number'
}

function isString (obj) {
  return typeof obj === 'string'
}

function isBoolean (obj) {
  return typeof obj === 'boolean'
}

function isPromiseSupported () {
  return typeof window !== 'undefined' && isExist(window.Promise)
}

function hasOwnProperty (o, k) {
  return Object.prototype.hasOwnProperty.call(o, k)
}

var script = {
  props: {
    value: Number,
    indicators: {
      type: Boolean,
      default: true
    },
    controls: {
      type: Boolean,
      default: true
    },
    interval: {
      type: Number,
      default: 5000
    },
    iconControlLeft: {
      type: String,
      default: 'glyphicon glyphicon-chevron-left'
    },
    iconControlRight: {
      type: String,
      default: 'glyphicon glyphicon-chevron-right'
    }
  },
  data: function data () {
    return {
      slides: [],
      activeIndex: 0, // Make v-model not required
      timeoutId: 0,
      intervalId: 0
    }
  },
  watch: {
    interval: function interval () {
      this.startInterval();
    },
    value: function value (index, oldValue) {
      this.run(index, oldValue);
      this.activeIndex = index;
    }
  },
  mounted: function mounted () {
    if (isExist(this.value)) {
      this.activeIndex = this.value;
    }
    if (this.slides.length > 0) {
      this.$select(this.activeIndex);
    }
    this.startInterval();
  },
  beforeDestroy: function beforeDestroy () {
    this.stopInterval();
  },
  methods: {
    run: function run (newIndex, oldIndex) {
      var this$1 = this;

      var currentActiveIndex = oldIndex || 0;
      var direction;
      if (newIndex > currentActiveIndex) {
        direction = ['next', 'left'];
      } else {
        direction = ['prev', 'right'];
      }
      this.slides[newIndex].slideClass[direction[0]] = true;
      this.$nextTick(function () {
        this$1.slides[newIndex].$el.offsetHeight;
        this$1.slides.forEach(function (slide, i) {
          if (i === currentActiveIndex) {
            slide.slideClass.active = true;
            slide.slideClass[direction[1]] = true;
          } else if (i === newIndex) {
            slide.slideClass[direction[1]] = true;
          }
        });
        this$1.timeoutId = setTimeout(function () {
          this$1.$select(newIndex);
          this$1.$emit('change', newIndex);
          this$1.timeoutId = 0;
        }, 600);
      });
    },
    startInterval: function startInterval () {
      var this$1 = this;

      this.stopInterval();
      if (this.interval > 0) {
        this.intervalId = setInterval(function () {
          this$1.next();
        }, this.interval);
      }
    },
    stopInterval: function stopInterval () {
      clearInterval(this.intervalId);
      this.intervalId = 0;
    },
    resetAllSlideClass: function resetAllSlideClass () {
      this.slides.forEach(function (slide) {
        slide.slideClass.active = false;
        slide.slideClass.left = false;
        slide.slideClass.right = false;
        slide.slideClass.next = false;
        slide.slideClass.prev = false;
      });
    },
    $select: function $select (index) {
      this.resetAllSlideClass();
      this.slides[index].slideClass.active = true;
    },
    select: function select (index) {
      if (this.timeoutId !== 0 || index === this.activeIndex) {
        return
      }
      if (isExist(this.value)) {
        this.$emit('input', index);
      } else {
        this.run(index, this.activeIndex);
        this.activeIndex = index;
      }
    },
    prev: function prev () {
      this.select(this.activeIndex === 0 ? this.slides.length - 1 : this.activeIndex - 1);
    },
    next: function next () {
      this.select(this.activeIndex === this.slides.length - 1 ? 0 : this.activeIndex + 1);
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    var options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            var originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            var existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "carousel slide",
      attrs: { "data-ride": "carousel" },
      on: { mouseenter: _vm.stopInterval, mouseleave: _vm.startInterval }
    },
    [
      _vm.indicators
        ? _vm._t(
            "indicators",
            [
              _c(
                "ol",
                { staticClass: "carousel-indicators" },
                _vm._l(_vm.slides, function(slide, index) {
                  return _c("li", {
                    class: { active: index === _vm.activeIndex },
                    on: {
                      click: function($event) {
                        return _vm.select(index)
                      }
                    }
                  })
                }),
                0
              )
            ],
            { select: _vm.select, activeIndex: _vm.activeIndex }
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "carousel-inner", attrs: { role: "listbox" } },
        [_vm._t("default")],
        2
      ),
      _vm._v(" "),
      _vm.controls
        ? _c(
            "a",
            {
              staticClass: "left carousel-control",
              attrs: { href: "#", role: "button" },
              on: {
                click: function($event) {
                  $event.preventDefault();
                  return _vm.prev()
                }
              }
            },
            [
              _c("span", {
                class: _vm.iconControlLeft,
                attrs: { "aria-hidden": "true" }
              }),
              _vm._v(" "),
              _c("span", { staticClass: "sr-only" }, [_vm._v("Previous")])
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.controls
        ? _c(
            "a",
            {
              staticClass: "right carousel-control",
              attrs: { href: "#", role: "button" },
              on: {
                click: function($event) {
                  $event.preventDefault();
                  return _vm.next()
                }
              }
            },
            [
              _c("span", {
                class: _vm.iconControlRight,
                attrs: { "aria-hidden": "true" }
              }),
              _vm._v(" "),
              _c("span", { staticClass: "sr-only" }, [_vm._v("Next")])
            ]
          )
        : _vm._e()
    ],
    2
  )
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = undefined;
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__ = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

function spliceIfExist (arr, item) {
  if (Array.isArray(arr)) {
    var index = arr.indexOf(item);
    if (index >= 0) {
      arr.splice(index, 1);
    }
  }
}

function range (end, start, step) {
  if ( start === void 0 ) start = 0;
  if ( step === void 0 ) step = 1;

  var arr = [];
  for (var i = start; i < end; i += step) {
    arr.push(i);
  }
  return arr
}

function nodeListToArray (nodeList) {
  return Array.prototype.slice.call(nodeList || [])
}

function onlyUnique (value, index, self) {
  return self.indexOf(value) === index
}

var script$1 = {
  data: function data () {
    return {
      slideClass: {
        active: false,
        prev: false,
        next: false,
        left: false,
        right: false
      }
    }
  },
  created: function created () {
    try {
      this.$parent.slides.push(this);
    } catch (e) {
      throw new Error('Slide parent must be Carousel.')
    }
  },
  beforeDestroy: function beforeDestroy () {
    var slides = this.$parent && this.$parent.slides;
    spliceIfExist(slides, this);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { staticClass: "item", class: _vm.slideClass },
    [_vm._t("default")],
    2
  )
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$1 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    false,
    undefined,
    undefined,
    undefined
  );

var EVENTS = {
  MOUSE_ENTER: 'mouseenter',
  MOUSE_LEAVE: 'mouseleave',
  MOUSE_DOWN: 'mousedown',
  MOUSE_UP: 'mouseup',
  FOCUS: 'focus',
  BLUR: 'blur',
  CLICK: 'click',
  INPUT: 'input',
  KEY_DOWN: 'keydown',
  KEY_UP: 'keyup',
  KEY_PRESS: 'keypress',
  RESIZE: 'resize',
  SCROLL: 'scroll',
  TOUCH_START: 'touchstart',
  TOUCH_END: 'touchend'
};

var TRIGGERS = {
  CLICK: 'click',
  HOVER: 'hover',
  FOCUS: 'focus',
  HOVER_FOCUS: 'hover-focus',
  OUTSIDE_CLICK: 'outside-click',
  MANUAL: 'manual'
};

var PLACEMENTS = {
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left'
};

function isIE11 () {
  /* istanbul ignore next */
  return !!window.MSInputMethodContext && !!document.documentMode
}

function isIE10 () {
  return window.navigator.appVersion.indexOf('MSIE 10') !== -1
}

function getComputedStyle (el) {
  return window.getComputedStyle(el)
}

function getViewportSize () {
  /* istanbul ignore next */
  var width = Math.max(document.documentElement.clientWidth, window.innerWidth) || 0;
  /* istanbul ignore next */
  var height = Math.max(document.documentElement.clientHeight, window.innerHeight) || 0;
  return { width: width, height: height }
}

var scrollbarWidth = null;
var savedScreenSize = null;

function getScrollbarWidth (recalculate) {
  if ( recalculate === void 0 ) recalculate = false;

  var screenSize = getViewportSize();
  // return directly when already calculated & not force recalculate & screen size not changed
  if (scrollbarWidth !== null && !recalculate &&
    screenSize.height === savedScreenSize.height && screenSize.width === savedScreenSize.width) {
    return scrollbarWidth
  }
  /* istanbul ignore next */
  if (document.readyState === 'loading') {
    return null
  }
  var div1 = document.createElement('div');
  var div2 = document.createElement('div');
  div1.style.width = div2.style.width = div1.style.height = div2.style.height = '100px';
  div1.style.overflow = 'scroll';
  div2.style.overflow = 'hidden';
  document.body.appendChild(div1);
  document.body.appendChild(div2);
  scrollbarWidth = Math.abs(div1.scrollHeight - div2.scrollHeight);
  document.body.removeChild(div1);
  document.body.removeChild(div2);
  // save new screen size
  savedScreenSize = screenSize;
  return scrollbarWidth
}

function on (element, event, handler) {
  /* istanbul ignore next */
  element.addEventListener(event, handler);
}

function off (element, event, handler) {
  /* istanbul ignore next */
  element.removeEventListener(event, handler);
}

function isElement (el) {
  return el && el.nodeType === Node.ELEMENT_NODE
}

function removeFromDom (el) {
  isElement(el) && isElement(el.parentNode) && el.parentNode.removeChild(el);
}

function ensureElementMatchesFunction () {
  /* istanbul ignore next */
  if (!Element.prototype.matches) {
    Element.prototype.matches =
      Element.prototype.matchesSelector ||
      Element.prototype.mozMatchesSelector ||
      Element.prototype.msMatchesSelector ||
      Element.prototype.oMatchesSelector ||
      Element.prototype.webkitMatchesSelector ||
      function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s);
        var i = matches.length;
        // eslint-disable-next-line no-empty
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1
      };
  }
}

function addClass (el, className) {
  if (!isElement(el)) {
    return
  }
  if (el.className) {
    var classes = el.className.split(' ');
    if (classes.indexOf(className) < 0) {
      classes.push(className);
      el.className = classes.join(' ');
    }
  } else {
    el.className = className;
  }
}

function removeClass (el, className) {
  if (!isElement(el)) {
    return
  }
  if (el.className) {
    var classes = el.className.split(' ');
    var newClasses = [];
    for (var i = 0, l = classes.length; i < l; i++) {
      if (classes[i] !== className) {
        newClasses.push(classes[i]);
      }
    }
    el.className = newClasses.join(' ');
  }
}

function hasClass (el, className) {
  if (!isElement(el)) {
    return false
  }
  var classes = el.className.split(' ');
  for (var i = 0, l = classes.length; i < l; i++) {
    if (classes[i] === className) {
      return true
    }
  }
  return false
}

function setDropdownPosition (dropdown, trigger, options) {
  if ( options === void 0 ) options = {};

  var doc = document.documentElement;
  var containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
  var containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
  var rect = trigger.getBoundingClientRect();
  var dropdownRect = dropdown.getBoundingClientRect();
  dropdown.style.right = 'auto';
  dropdown.style.bottom = 'auto';
  if (options.menuRight) {
    dropdown.style.left = containerScrollLeft + rect.left + rect.width - dropdownRect.width + 'px';
  } else {
    dropdown.style.left = containerScrollLeft + rect.left + 'px';
  }
  if (options.dropup) {
    dropdown.style.top = containerScrollTop + rect.top - dropdownRect.height - 4 + 'px';
  } else {
    dropdown.style.top = containerScrollTop + rect.top + rect.height + 'px';
  }
}

function isAvailableAtPosition (trigger, popup, placement) {
  var triggerRect = trigger.getBoundingClientRect();
  var popupRect = popup.getBoundingClientRect();
  var viewPortSize = getViewportSize();
  var top = true;
  var right = true;
  var bottom = true;
  var left = true;
  switch (placement) {
    case PLACEMENTS.TOP:
      top = triggerRect.top >= popupRect.height;
      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2;
      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width;
      break
    case PLACEMENTS.BOTTOM:
      bottom = triggerRect.bottom + popupRect.height <= viewPortSize.height;
      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2;
      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width;
      break
    case PLACEMENTS.RIGHT:
      right = triggerRect.right + popupRect.width <= viewPortSize.width;
      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2;
      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height;
      break
    case PLACEMENTS.LEFT:
      left = triggerRect.left >= popupRect.width;
      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2;
      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height;
      break
  }
  return top && right && bottom && left
}

function setTooltipPosition (tooltip, trigger, placement, auto, appendTo, viewport) {
  if (!isElement(tooltip) || !isElement(trigger)) {
    return
  }
  var isPopover = tooltip && tooltip.className && tooltip.className.indexOf('popover') >= 0;
  var containerScrollTop;
  var containerScrollLeft;
  if (!isExist(appendTo) || appendTo === 'body') {
    var doc = document.documentElement;
    containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
  } else {
    var container = getElementBySelectorOrRef(appendTo);
    containerScrollLeft = container.scrollLeft;
    containerScrollTop = container.scrollTop;
  }
  // auto adjust placement
  if (auto) {
    // Try: right -> bottom -> left -> top
    // Cause the default placement is top
    var placements = [PLACEMENTS.RIGHT, PLACEMENTS.BOTTOM, PLACEMENTS.LEFT, PLACEMENTS.TOP];
    // The class switch helper function
    var changePlacementClass = function (placement) {
      // console.log(placement)
      placements.forEach(function (placement) {
        removeClass(tooltip, placement);
      });
      addClass(tooltip, placement);
    };
    // No need to adjust if the default placement fits
    if (!isAvailableAtPosition(trigger, tooltip, placement)) {
      for (var i = 0, l = placements.length; i < l; i++) {
        // Re-assign placement class
        changePlacementClass(placements[i]);
        // Break if new placement fits
        if (isAvailableAtPosition(trigger, tooltip, placements[i])) {
          placement = placements[i];
          break
        }
      }
      changePlacementClass(placement);
    }
  }
  // fix left and top for tooltip
  var rect = trigger.getBoundingClientRect();
  var tooltipRect = tooltip.getBoundingClientRect();
  var top;
  var left;
  if (placement === PLACEMENTS.BOTTOM) {
    top = containerScrollTop + rect.top + rect.height;
    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2;
  } else if (placement === PLACEMENTS.LEFT) {
    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2;
    left = containerScrollLeft + rect.left - tooltipRect.width;
  } else if (placement === PLACEMENTS.RIGHT) {
    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2;
    // https://github.com/uiv-lib/uiv/issues/272
    // add 1px to fix above issue
    left = containerScrollLeft + rect.left + rect.width + 1;
  } else {
    top = containerScrollTop + rect.top - tooltipRect.height;
    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2;
  }
  var viewportEl;
  // viewport option
  if (isString(viewport)) {
    viewportEl = document.querySelector(viewport);
  } else if (isFunction(viewport)) {
    viewportEl = viewport(trigger);
  }
  if (isElement(viewportEl)) {
    var popoverFix = isPopover ? 11 : 0;
    var viewportReact = viewportEl.getBoundingClientRect();
    var viewportTop = containerScrollTop + viewportReact.top;
    var viewportLeft = containerScrollLeft + viewportReact.left;
    var viewportBottom = viewportTop + viewportReact.height;
    var viewportRight = viewportLeft + viewportReact.width;
    // fix top
    if (top < viewportTop) {
      top = viewportTop;
    } else if (top + tooltipRect.height > viewportBottom) {
      top = viewportBottom - tooltipRect.height;
    }
    // fix left
    if (left < viewportLeft) {
      left = viewportLeft;
    } else if (left + tooltipRect.width > viewportRight) {
      left = viewportRight - tooltipRect.width;
    }
    // fix for popover pointer
    if (placement === PLACEMENTS.BOTTOM) {
      top -= popoverFix;
    } else if (placement === PLACEMENTS.LEFT) {
      left += popoverFix;
    } else if (placement === PLACEMENTS.RIGHT) {
      left -= popoverFix;
    } else {
      top += popoverFix;
    }
  }
  // set position finally
  tooltip.style.top = top + "px";
  tooltip.style.left = left + "px";
}

function hasScrollbar (el) {
  var SCROLL = 'scroll';
  var hasVScroll = el.scrollHeight > el.clientHeight;
  var style = getComputedStyle(el);
  return hasVScroll || style.overflow === SCROLL || style.overflowY === SCROLL
}

function toggleBodyOverflow (enable) {
  var MODAL_OPEN = 'modal-open';
  var FIXED_CONTENT = '.navbar-fixed-top, .navbar-fixed-bottom';
  var body = document.body;
  if (enable) {
    removeClass(body, MODAL_OPEN);
    body.style.paddingRight = null;
    nodeListToArray(document.querySelectorAll(FIXED_CONTENT)).forEach(function (node) {
      node.style.paddingRight = null;
    });
  } else {
    var browsersWithFloatingScrollbar = isIE10() || isIE11();
    var documentHasScrollbar = hasScrollbar(document.documentElement) || hasScrollbar(document.body);
    if (documentHasScrollbar && !browsersWithFloatingScrollbar) {
      var scrollbarWidth = getScrollbarWidth();
      body.style.paddingRight = scrollbarWidth + "px";
      nodeListToArray(document.querySelectorAll(FIXED_CONTENT)).forEach(function (node) {
        node.style.paddingRight = scrollbarWidth + "px";
      });
    }
    addClass(body, MODAL_OPEN);
  }
}

function getClosest (el, selector) {
  ensureElementMatchesFunction();
  var parent;
  var _el = el;
  while (_el) {
    parent = _el.parentElement;
    if (parent && parent.matches(selector)) {
      return parent
    }
    _el = parent;
  }
  return null
}

function getParents (el, selector, until) {
  if ( until === void 0 ) until = null;

  ensureElementMatchesFunction();
  var parents = [];
  var parent = el.parentElement;
  while (parent) {
    if (parent.matches(selector)) {
      parents.push(parent);
    } else if (until && (until === parent || parent.matches(until))) {
      break
    }
    parent = parent.parentElement;
  }
  return parents
}

function focus (el) {
  if (!isElement(el)) {
    return
  }
  el.getAttribute('tabindex') ? null : el.setAttribute('tabindex', '-1');
  el.focus();
}

var MODAL_BACKDROP = 'modal-backdrop';

function getOpenModals () {
  return document.querySelectorAll(("." + MODAL_BACKDROP))
}

function getOpenModalNum () {
  return getOpenModals().length
}

function getElementBySelectorOrRef (q) {
  if (isString(q)) { // is selector
    return document.querySelector(q)
  } else if (isElement(q)) { // is element
    return q
  } else if (isElement(q.$el)) { // is component
    return q.$el
  } else {
    return null
  }
}

var COLLAPSE = 'collapse';
var IN = 'in';
var COLLAPSING = 'collapsing';

var Collapse = {
  render: function render (h) {
    return h(this.tag, {}, this.$slots.default)
  },
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    value: {
      type: Boolean,
      default: false
    },
    transition: {
      type: Number,
      default: 350
    }
  },
  data: function data () {
    return {
      timeoutId: 0
    }
  },
  watch: {
    value: function value (show) {
      this.toggle(show);
    }
  },
  mounted: function mounted () {
    var el = this.$el;
    addClass(el, COLLAPSE);
    if (this.value) {
      addClass(el, IN);
    }
  },
  methods: {
    toggle: function toggle (show) {
      var this$1 = this;

      clearTimeout(this.timeoutId);
      var el = this.$el;
      if (show) {
        this.$emit('show');
        removeClass(el, COLLAPSE);
        el.style.height = 'auto';
        var height = window.getComputedStyle(el).height;
        el.style.height = null;
        addClass(el, COLLAPSING);
        el.offsetHeight; // force repaint
        el.style.height = height;
        this.timeoutId = setTimeout(function () {
          removeClass(el, COLLAPSING);
          addClass(el, COLLAPSE);
          addClass(el, IN);
          el.style.height = null;
          this$1.timeoutId = 0;
          this$1.$emit('shown');
        }, this.transition);
      } else {
        this.$emit('hide');
        el.style.height = window.getComputedStyle(el).height;
        removeClass(el, IN);
        removeClass(el, COLLAPSE);
        el.offsetHeight;
        el.style.height = null;
        addClass(el, COLLAPSING);
        this.timeoutId = setTimeout(function () {
          addClass(el, COLLAPSE);
          removeClass(el, COLLAPSING);
          el.style.height = null;
          this$1.timeoutId = 0;
          this$1.$emit('hidden');
        }, this.transition);
      }
    }
  }
};

var DEFAULT_TAG = 'div';

var Dropdown = {
  render: function render (h) {
    return h(
      this.tag,
      {
        class: {
          'btn-group': this.tag === DEFAULT_TAG,
          dropdown: !this.dropup,
          dropup: this.dropup,
          open: this.show
        }
      },
      [
        this.$slots.default,
        h(
          'ul',
          {
            class: {
              'dropdown-menu': true,
              'dropdown-menu-right': this.menuRight
            },
            ref: 'dropdown'
          },
          [this.$slots.dropdown]
        )
      ]
    )
  },
  props: {
    tag: {
      type: String,
      default: DEFAULT_TAG
    },
    appendToBody: {
      type: Boolean,
      default: false
    },
    value: Boolean,
    dropup: {
      type: Boolean,
      default: false
    },
    menuRight: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    notCloseElements: Array,
    positionElement: null
  },
  data: function data () {
    return {
      show: false,
      triggerEl: undefined
    }
  },
  watch: {
    value: function value (v) {
      this.toggle(v);
    }
  },
  mounted: function mounted () {
    this.initTrigger();
    if (this.triggerEl) {
      on(this.triggerEl, EVENTS.CLICK, this.toggle);
      on(this.triggerEl, EVENTS.KEY_DOWN, this.onKeyPress);
    }
    on(this.$refs.dropdown, EVENTS.KEY_DOWN, this.onKeyPress);
    on(window, EVENTS.CLICK, this.windowClicked);
    on(window, EVENTS.TOUCH_END, this.windowClicked);
    if (this.value) {
      this.toggle(true);
    }
  },
  beforeDestroy: function beforeDestroy () {
    this.removeDropdownFromBody();
    if (this.triggerEl) {
      off(this.triggerEl, EVENTS.CLICK, this.toggle);
      off(this.triggerEl, EVENTS.KEY_DOWN, this.onKeyPress);
    }
    off(this.$refs.dropdown, EVENTS.KEY_DOWN, this.onKeyPress);
    off(window, EVENTS.CLICK, this.windowClicked);
    off(window, EVENTS.TOUCH_END, this.windowClicked);
  },
  methods: {
    getFocusItem: function getFocusItem () {
      var dropdownEl = this.$refs.dropdown;
      /* istanbul ignore next */
      return dropdownEl.querySelector('li > a:focus')
    },
    onKeyPress: function onKeyPress (event) {
      if (this.show) {
        var dropdownEl = this.$refs.dropdown;
        var keyCode = event.keyCode;
        if (keyCode === 27) {
          // esc
          this.toggle(false);
          this.triggerEl && this.triggerEl.focus();
        } else if (keyCode === 13) {
          // enter
          var currentFocus = this.getFocusItem();
          currentFocus && currentFocus.click();
        } else if (keyCode === 38 || keyCode === 40) {
          // up || down
          event.preventDefault();
          event.stopPropagation();
          var currentFocus$1 = this.getFocusItem();
          var items = dropdownEl.querySelectorAll('li:not(.disabled) > a');
          if (!currentFocus$1) {
            focus(items[0]);
          } else {
            for (var i = 0; i < items.length; i++) {
              if (currentFocus$1 === items[i]) {
                if (keyCode === 38 && i < items.length > 0) {
                  focus(items[i - 1]);
                } else if (keyCode === 40 && i < items.length - 1) {
                  focus(items[i + 1]);
                }
                break
              }
            }
          }
        }
      }
    },
    initTrigger: function initTrigger () {
      var trigger = this.$el.querySelector('[data-role="trigger"]') || this.$el.querySelector('.dropdown-toggle') || this.$el.firstChild;
      this.triggerEl = trigger && trigger !== this.$refs.dropdown ? trigger : null;
    },
    toggle: function toggle (show) {
      if (this.disabled) {
        return
      }
      if (isBoolean(show)) {
        this.show = show;
      } else {
        this.show = !this.show;
      }
      if (this.appendToBody) {
        this.show ? this.appendDropdownToBody() : this.removeDropdownFromBody();
      }
      this.$emit('input', this.show);
    },
    windowClicked: function windowClicked (event) {
      var target = event.target;
      if (this.show && target) {
        var targetInNotCloseElements = false;
        if (this.notCloseElements) {
          for (var i = 0, l = this.notCloseElements.length; i < l; i++) {
            var isTargetInElement = this.notCloseElements[i].contains(target);
            var shouldBreak = isTargetInElement;
            /* istanbul ignore else */
            if (this.appendToBody) {
              var isTargetInDropdown = this.$refs.dropdown.contains(target);
              var isElInElements = this.notCloseElements.indexOf(this.$el) >= 0;
              shouldBreak = isTargetInElement || (isTargetInDropdown && isElInElements);
            }
            if (shouldBreak) {
              targetInNotCloseElements = true;
              break
            }
          }
        }
        var targetInDropdownBody = this.$refs.dropdown.contains(target);
        var targetInTrigger = this.$el.contains(target) && !targetInDropdownBody;
        // normally, a dropdown select event is handled by @click that trigger after @touchend
        // then @touchend event have to be ignore in this case
        var targetInDropdownAndIsTouchEvent = targetInDropdownBody && event.type === 'touchend';
        if (!targetInTrigger && !targetInNotCloseElements && !targetInDropdownAndIsTouchEvent) {
          this.toggle(false);
        }
      }
    },
    appendDropdownToBody: function appendDropdownToBody () {
      try {
        var el = this.$refs.dropdown;
        el.style.display = 'block';
        document.body.appendChild(el);
        var positionElement = this.positionElement || this.$el;
        setDropdownPosition(el, positionElement, this);
      } catch (e) {
        // Silent
      }
    },
    removeDropdownFromBody: function removeDropdownFromBody () {
      try {
        var el = this.$refs.dropdown;
        el.removeAttribute('style');
        this.$el.appendChild(el);
      } catch (e) {
        // Silent
      }
    }
  }
};

var defaultLang = {
  uiv: {
    datePicker: {
      clear: 'Clear',
      today: 'Today',
      month: 'Month',
      month1: 'January',
      month2: 'February',
      month3: 'March',
      month4: 'April',
      month5: 'May',
      month6: 'June',
      month7: 'July',
      month8: 'August',
      month9: 'September',
      month10: 'October',
      month11: 'November',
      month12: 'December',
      year: 'Year',
      week1: 'Mon',
      week2: 'Tue',
      week3: 'Wed',
      week4: 'Thu',
      week5: 'Fri',
      week6: 'Sat',
      week7: 'Sun'
    },
    timePicker: {
      am: 'AM',
      pm: 'PM'
    },
    modal: {
      cancel: 'Cancel',
      ok: 'OK'
    },
    multiSelect: {
      placeholder: 'Select...',
      filterPlaceholder: 'Search...'
    }
  }
};

// https://github.com/ElemeFE/element/blob/dev/src/locale/index.js

var lang = defaultLang;

var i18nHandler = function () {
  var vuei18n = Object.getPrototypeOf(this).$t;
  /* istanbul ignore else */
  /* istanbul ignore next */
  if (isFunction(vuei18n)) {
    /* istanbul ignore next */
    try {
      return vuei18n.apply(this, arguments)
    } catch (err) {
      return this.$t.apply(this, arguments)
    }
  }
};

var t = function (path, options) {
  options = options || {};
  var value;
  try {
    value = i18nHandler.apply(this, arguments);
    /* istanbul ignore next */
    if (isExist(value) && !options.$$locale) {
      return value
    }
  } catch (e) {
    // ignore
  }
  var array = path.split('.');
  var current = options.$$locale || lang;

  for (var i = 0, j = array.length; i < j; i++) {
    var property = array[i];
    value = current[property];
    if (i === j - 1) { return value }
    if (!value) { return '' }
    current = value;
  }
  /* istanbul ignore next */
  return ''
};

var use = function (l) {
  lang = l || lang;
};

var i18n = function (fn) {
  i18nHandler = fn || i18nHandler;
};

var locale = { use: use, t: t, i18n: i18n };

var Local = {
  methods: {
    t: function t$1 () {
      var arguments$1 = arguments;

      var args = [];
      for (var i = 0; i < arguments.length; ++i) {
        args.push(arguments$1[i]);
      }
      args[1] = assign({}, { $$locale: this.locale }, args[1]);
      return t.apply(this, args)
    }
  },
  props: {
    locale: Object
  }
};

var e=function(){return (e=Object.assign||function(e){for(var t,r=1,s=arguments.length;r<s;r++){ for(var a in t=arguments[r]){ Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]); } }return e}).apply(this,arguments)},t$1={kebab:/-(\w)/g,styleProp:/:(.*)/,styleList:/;(?![^(]*\))/g};function r(e,t){return t?t.toUpperCase():""}function s(e){for(var s,a={},c=0,o=e.split(t$1.styleList);c<o.length;c++){var n=o[c].split(t$1.styleProp),i=n[0],l=n[1];(i=i.trim())&&("string"==typeof l&&(l=l.trim()),a[(s=i,s.replace(t$1.kebab,r))]=l);}return a}function a(){
var arguments$1 = arguments;
for(var t,r,a={},c=arguments.length;c--;){ for(var o=0,n=Object.keys(arguments[c]);o<n.length;o++){ switch(t=n[o]){case"class":case"style":case"directives":if(Array.isArray(a[t])||(a[t]=[]),"style"===t){var i=void 0;i=Array.isArray(arguments$1[c].style)?arguments$1[c].style:[arguments$1[c].style];for(var l=0;l<i.length;l++){var y=i[l];"string"==typeof y&&(i[l]=s(y));}arguments$1[c].style=i;}a[t]=a[t].concat(arguments$1[c][t]);break;case"staticClass":if(!arguments$1[c][t]){ break; }void 0===a[t]&&(a[t]=""),a[t]&&(a[t]+=" "),a[t]+=arguments$1[c][t].trim();break;case"on":case"nativeOn":a[t]||(a[t]={});for(var p=0,f=Object.keys(arguments[c][t]||{});p<f.length;p++){ r=f[p],a[t][r]?a[t][r]=[].concat(a[t][r],arguments$1[c][t][r]):a[t][r]=arguments$1[c][t][r]; }break;case"attrs":case"props":case"domProps":case"scopedSlots":case"staticStyle":case"hook":case"transition":a[t]||(a[t]={}),a[t]=e({},arguments$1[c][t],a[t]);break;case"slot":case"key":case"ref":case"tag":case"show":case"keepAlive":default:a[t]||(a[t]=arguments$1[c][t]);} } }return a}

var linkMixin = {
  props: {
    // <a> props
    href: String,
    target: String,
    // <router-link> props
    to: null,
    replace: {
      type: Boolean,
      default: false
    },
    append: {
      type: Boolean,
      default: false
    },
    exact: {
      type: Boolean,
      default: false
    }
  }
};

var BtnGroup = {
  functional: true,
  render: function render (h, ref) {
    var obj;

    var props = ref.props;
    var children = ref.children;
    var data = ref.data;
    return h(
      'div',
      a(data, {
        class: ( obj = {
          'btn-group': !props.vertical,
          'btn-group-vertical': props.vertical,
          'btn-group-justified': props.justified
        }, obj[("btn-group-" + (props.size))] = props.size, obj ),
        attrs: {
          role: 'group',
          'data-toggle': 'buttons'
        }
      }),
      children
    )
  },
  props: {
    size: String,
    vertical: {
      type: Boolean,
      default: false
    },
    justified: {
      type: Boolean,
      default: false
    }
  }
};

var INPUT_TYPE_CHECKBOX = 'checkbox';
var INPUT_TYPE_RADIO = 'radio';

var Btn = {
  functional: true,
  mixins: [linkMixin],
  render: function render (h, ref) {
    var children = ref.children;
    var props = ref.props;
    var data = ref.data;

    // event listeners
    var listeners = data.on || {};
    // checkbox: model contain inputValue
    // radio: model === inputValue
    var isInputActive = props.inputType === INPUT_TYPE_CHECKBOX ? props.value.indexOf(props.inputValue) >= 0 : props.value === props.inputValue;
    // button class
    var classes = {
      btn: true,
      active: props.inputType ? isInputActive : props.active,
      disabled: props.disabled,
      'btn-block': props.block
    };
    classes[("btn-" + (props.type))] = Boolean(props.type);
    classes[("btn-" + (props.size))] = Boolean(props.size);
    // prevent event for disabled links
    var on = {
      click: function click (e) {
        if (props.disabled && e instanceof Event) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };
    // render params
    var tag, options, slot;

    if (props.href) {
      // is native link
      tag = 'a';
      slot = children;
      options = a(data, {
        on: on,
        class: classes,
        attrs: {
          role: 'button',
          href: props.href,
          target: props.target
        }
      });
    } else if (props.to) {
      // is vue router link
      tag = 'router-link';
      slot = children;
      options = a(data, {
        nativeOn: on,
        class: classes,
        props: {
          event: props.disabled ? '' : 'click', // prevent nav while disabled
          to: props.to,
          replace: props.replace,
          append: props.append,
          exact: props.exact
        },
        attrs: {
          role: 'button'
        }
      });
    } else if (props.inputType) {
      // is input checkbox or radio
      tag = 'label';
      options = a(data, {
        on: on,
        class: classes
      });
      slot = [
        h('input', {
          attrs: {
            autocomplete: 'off',
            type: props.inputType,
            checked: isInputActive ? 'checked' : null,
            disabled: props.disabled
          },
          domProps: {
            checked: isInputActive // required
          },
          on: {
            input: function input (evt) {
              evt.stopPropagation();
            },
            change: function change () {
              if (props.inputType === INPUT_TYPE_CHECKBOX) {
                var valueCopied = props.value.slice();
                if (isInputActive) {
                  valueCopied.splice(valueCopied.indexOf(props.inputValue), 1);
                } else {
                  valueCopied.push(props.inputValue);
                }
                listeners.input(valueCopied);
              } else {
                listeners.input(props.inputValue);
              }
            }
          }
        }),
        children
      ];
    } else if (props.justified) {
      // is in justified btn-group
      tag = BtnGroup;
      options = {};
      slot = [
        h('button', a(data, {
          on: on,
          class: classes,
          attrs: {
            type: props.nativeType,
            disabled: props.disabled
          }
        }), children)
      ];
    } else {
      // is button
      tag = 'button';
      slot = children;
      options = a(data, {
        on: on,
        class: classes,
        attrs: {
          type: props.nativeType,
          disabled: props.disabled
        }
      });
    }

    return h(tag, options, slot)
  },
  props: {
    justified: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'default'
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    size: String,
    block: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    // <input> props
    value: null,
    inputValue: null,
    inputType: {
      type: String,
      validator: function validator (value) {
        return value === INPUT_TYPE_CHECKBOX || value === INPUT_TYPE_RADIO
      }
    }
  }
};

var IN$1 = 'in';

var script$2 = {
  mixins: [Local],
  components: { Btn: Btn },
  props: {
    value: {
      type: Boolean,
      default: false
    },
    title: String,
    size: String,
    backdrop: {
      type: Boolean,
      default: true
    },
    footer: {
      type: Boolean,
      default: true
    },
    header: {
      type: Boolean,
      default: true
    },
    cancelText: String,
    cancelType: {
      type: String,
      default: 'default'
    },
    okText: String,
    okType: {
      type: String,
      default: 'primary'
    },
    dismissBtn: {
      type: Boolean,
      default: true
    },
    transition: {
      type: Number,
      default: 150
    },
    autoFocus: {
      type: Boolean,
      default: false
    },
    keyboard: {
      type: Boolean,
      default: true
    },
    beforeClose: Function,
    zOffset: {
      type: Number,
      default: 20
    },
    appendToBody: {
      type: Boolean,
      default: false
    },
    displayStyle: {
      type: String,
      default: 'block'
    }
  },
  data: function data () {
    return {
      msg: ''
    }
  },
  computed: {
    modalSizeClass: function modalSizeClass () {
      var obj;

      return ( obj = {}, obj[("modal-" + (this.size))] = Boolean(this.size), obj )
    }
  },
  watch: {
    value: function value (v) {
      this.$toggle(v);
    }
  },
  mounted: function mounted () {
    removeFromDom(this.$refs.backdrop);
    on(window, EVENTS.MOUSE_DOWN, this.suppressBackgroundClose);
    on(window, EVENTS.KEY_UP, this.onKeyPress);
    if (this.value) {
      this.$toggle(true);
    }
  },
  beforeDestroy: function beforeDestroy () {
    clearTimeout(this.timeoutId);
    removeFromDom(this.$refs.backdrop);
    removeFromDom(this.$el);
    if (getOpenModalNum() === 0) {
      toggleBodyOverflow(true);
    }
    off(window, EVENTS.MOUSE_DOWN, this.suppressBackgroundClose);
    off(window, EVENTS.MOUSE_UP, this.unsuppressBackgroundClose);
    off(window, EVENTS.KEY_UP, this.onKeyPress);
  },
  methods: {
    onKeyPress: function onKeyPress (event) {
      if (this.keyboard && this.value && event.keyCode === 27) {
        var thisModal = this.$refs.backdrop;
        var thisZIndex = thisModal.style.zIndex;
        thisZIndex = thisZIndex && thisZIndex !== 'auto' ? parseInt(thisZIndex) : 0;
        // Find out if this modal is the top most one.
        var modals = getOpenModals();
        var modalsLength = modals.length;
        for (var i = 0; i < modalsLength; i++) {
          if (modals[i] !== thisModal) {
            var zIndex = modals[i].style.zIndex;
            zIndex = zIndex && zIndex !== 'auto' ? parseInt(zIndex) : 0;
            // if any existing modal has higher zIndex, ignore
            if (zIndex > thisZIndex) {
              return
            }
          }
        }
        this.toggle(false);
      }
    },
    toggle: function toggle (show, msg) {
      var this$1 = this;

      var shouldClose = true;
      if (isFunction(this.beforeClose)) {
        shouldClose = this.beforeClose(msg);
      }

      if (isPromiseSupported()) {
        // Skip the hiding when beforeClose returning falsely value or returned Promise resolves to falsely value
        // Use Promise.resolve to accept both Boolean values and Promises
        Promise.resolve(shouldClose).then(function (shouldClose) {
          // Skip the hiding while show===false
          if (!show && shouldClose) {
            this$1.msg = msg;
            this$1.$emit('input', show);
          }
        });
      } else {
        // Fallback to old version if promise is not supported
        // skip the hiding while show===false & beforeClose returning falsely value
        if (!show && !shouldClose) {
          return
        }

        this.msg = msg;
        this.$emit('input', show);
      }
    },
    $toggle: function $toggle (show) {
      var this$1 = this;

      var modal = this.$el;
      var backdrop = this.$refs.backdrop;
      clearTimeout(this.timeoutId);
      if (show) {
        // If two modals share the same v-if condition the calculated z-index is incorrect,
        // resulting in popover misbehaviour.
        // solved by adding a nextTick.
        // https://github.com/uiv-lib/uiv/issues/342
        this.$nextTick(function () {
          var alreadyOpenModalNum = getOpenModalNum();
          document.body.appendChild(backdrop);
          if (this$1.appendToBody) {
            document.body.appendChild(modal);
          }
          modal.style.display = this$1.displayStyle;
          modal.scrollTop = 0;
          backdrop.offsetHeight; // force repaint
          toggleBodyOverflow(false);
          addClass(backdrop, IN$1);
          addClass(modal, IN$1);
          // fix z-index for nested modals
          // no need to calculate if no modal is already open
          if (alreadyOpenModalNum > 0) {
            var modalBaseZ = parseInt(getComputedStyle(modal).zIndex) || 1050; // 1050 is default modal z-Index
            var backdropBaseZ = parseInt(getComputedStyle(backdrop).zIndex) || 1040; // 1040 is default backdrop z-Index
            var offset = alreadyOpenModalNum * this$1.zOffset;
            modal.style.zIndex = "" + (modalBaseZ + offset);
            backdrop.style.zIndex = "" + (backdropBaseZ + offset);
          }
          // z-index fix end
          this$1.timeoutId = setTimeout(function () {
            if (this$1.autoFocus) {
              var btn = this$1.$el.querySelector('[data-action="auto-focus"]');
              if (btn) {
                btn.focus();
              }
            }
            this$1.$emit('show');
            this$1.timeoutId = 0;
          }, this$1.transition);
        });
      } else {
        removeClass(backdrop, IN$1);
        removeClass(modal, IN$1);
        this.timeoutId = setTimeout(function () {
          modal.style.display = 'none';
          removeFromDom(backdrop);
          if (this$1.appendToBody) {
            removeFromDom(modal);
          }
          if (getOpenModalNum() === 0) {
            toggleBodyOverflow(true);
          }
          this$1.$emit('hide', this$1.msg || 'dismiss');
          this$1.msg = '';
          this$1.timeoutId = 0;
          // restore z-index for nested modals
          modal.style.zIndex = '';
          backdrop.style.zIndex = '';
          // z-index fix end
        }, this.transition);
      }
    },
    suppressBackgroundClose: function suppressBackgroundClose (event) {
      if (event && event.target === this.$el) {
        return
      }
      this.isCloseSuppressed = true;
      on(window, 'mouseup', this.unsuppressBackgroundClose);
    },
    unsuppressBackgroundClose: function unsuppressBackgroundClose () {
      var this$1 = this;

      if (this.isCloseSuppressed) {
        off(window, 'mouseup', this.unsuppressBackgroundClose);
        setTimeout(function () {
          this$1.isCloseSuppressed = false;
        }, 1);
      }
    },
    backdropClicked: function backdropClicked (event) {
      if (this.backdrop && !this.isCloseSuppressed) {
        this.toggle(false);
      }
    }
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */
var __vue_render__$2 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "modal",
      class: { fade: _vm.transition > 0 },
      attrs: { tabindex: "-1", role: "dialog" },
      on: {
        click: function($event) {
          if ($event.target !== $event.currentTarget) {
            return null
          }
          return _vm.backdropClicked($event)
        }
      }
    },
    [
      _c(
        "div",
        {
          ref: "dialog",
          staticClass: "modal-dialog",
          class: _vm.modalSizeClass,
          attrs: { role: "document" }
        },
        [
          _c("div", { staticClass: "modal-content" }, [
            _vm.header
              ? _c(
                  "div",
                  { staticClass: "modal-header" },
                  [
                    _vm._t("header", [
                      _vm.dismissBtn
                        ? _c(
                            "button",
                            {
                              staticClass: "close",
                              staticStyle: {
                                position: "relative",
                                "z-index": "1060"
                              },
                              attrs: { type: "button", "aria-label": "Close" },
                              on: {
                                click: function($event) {
                                  return _vm.toggle(false)
                                }
                              }
                            },
                            [
                              _c("span", { attrs: { "aria-hidden": "true" } }, [
                                _vm._v("")
                              ])
                            ]
                          )
                        : _vm._e(),
                      _vm._v(" "),
                      _c(
                        "h4",
                        { staticClass: "modal-title" },
                        [_vm._t("title", [_vm._v(_vm._s(_vm.title))])],
                        2
                      )
                    ])
                  ],
                  2
                )
              : _vm._e(),
            _vm._v(" "),
            _c("div", { staticClass: "modal-body" }, [_vm._t("default")], 2),
            _vm._v(" "),
            _vm.footer
              ? _c(
                  "div",
                  { staticClass: "modal-footer" },
                  [
                    _vm._t("footer", [
                      _c(
                        "btn",
                        {
                          attrs: { type: _vm.cancelType },
                          on: {
                            click: function($event) {
                              return _vm.toggle(false, "cancel")
                            }
                          }
                        },
                        [
                          _c("span", [
                            _vm._v(
                              _vm._s(
                                _vm.cancelText || _vm.t("uiv.modal.cancel")
                              )
                            )
                          ])
                        ]
                      ),
                      _vm._v(" "),
                      _c(
                        "btn",
                        {
                          attrs: {
                            type: _vm.okType,
                            "data-action": "auto-focus"
                          },
                          on: {
                            click: function($event) {
                              return _vm.toggle(false, "ok")
                            }
                          }
                        },
                        [
                          _c("span", [
                            _vm._v(_vm._s(_vm.okText || _vm.t("uiv.modal.ok")))
                          ])
                        ]
                      )
                    ])
                  ],
                  2
                )
              : _vm._e()
          ])
        ]
      ),
      _vm._v(" "),
      _c("div", {
        ref: "backdrop",
        staticClass: "modal-backdrop",
        class: { fade: _vm.transition > 0 }
      })
    ]
  )
};
var __vue_staticRenderFns__$2 = [];
__vue_render__$2._withStripped = true;

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$2 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    false,
    undefined,
    undefined,
    undefined
  );

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") { return Array.from(iter); }
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var inBrowser = typeof window !== 'undefined';
function freeze(item) {
  if (Array.isArray(item) || _typeof(item) === 'object') {
    return Object.freeze(item);
  }

  return item;
}
function combinePassengers(transports) {
  var slotProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return transports.reduce(function (passengers, transport) {
    var temp = transport.passengers[0];
    var newPassengers = typeof temp === 'function' ? temp(slotProps) : transport.passengers;
    return passengers.concat(newPassengers);
  }, []);
}
function stableSort(array, compareFn) {
  return array.map(function (v, idx) {
    return [idx, v];
  }).sort(function (a, b) {
    return compareFn(a[1], b[1]) || a[0] - b[0];
  }).map(function (c) {
    return c[1];
  });
}
function pick(obj, keys) {
  return keys.reduce(function (acc, key) {
    if (obj.hasOwnProperty(key)) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

var transports = {};
var targets = {};
var sources = {};
var Wormhole = Vue.extend({
  data: function data() {
    return {
      transports: transports,
      targets: targets,
      sources: sources,
      trackInstances: inBrowser
    };
  },
  methods: {
    open: function open(transport) {
      if (!inBrowser) { return; }
      var to = transport.to,
          from = transport.from,
          passengers = transport.passengers,
          _transport$order = transport.order,
          order = _transport$order === void 0 ? Infinity : _transport$order;
      if (!to || !from || !passengers) { return; }
      var newTransport = {
        to: to,
        from: from,
        passengers: freeze(passengers),
        order: order
      };
      var keys = Object.keys(this.transports);

      if (keys.indexOf(to) === -1) {
        Vue.set(this.transports, to, []);
      }

      var currentIndex = this.$_getTransportIndex(newTransport); // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays

      var newTransports = this.transports[to].slice(0);

      if (currentIndex === -1) {
        newTransports.push(newTransport);
      } else {
        newTransports[currentIndex] = newTransport;
      }

      this.transports[to] = stableSort(newTransports, function (a, b) {
        return a.order - b.order;
      });
    },
    close: function close(transport) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var to = transport.to,
          from = transport.from;
      if (!to || !from && force === false) { return; }

      if (!this.transports[to]) {
        return;
      }

      if (force) {
        this.transports[to] = [];
      } else {
        var index = this.$_getTransportIndex(transport);

        if (index >= 0) {
          // Copying the array here so that the PortalTarget change event will actually contain two distinct arrays
          var newTransports = this.transports[to].slice(0);
          newTransports.splice(index, 1);
          this.transports[to] = newTransports;
        }
      }
    },
    registerTarget: function registerTarget(target, vm, force) {
      if (!inBrowser) { return; }

      if (this.trackInstances && !force && this.targets[target]) {
        console.warn("[portal-vue]: Target ".concat(target, " already exists"));
      }

      this.$set(this.targets, target, Object.freeze([vm]));
    },
    unregisterTarget: function unregisterTarget(target) {
      this.$delete(this.targets, target);
    },
    registerSource: function registerSource(source, vm, force) {
      if (!inBrowser) { return; }

      if (this.trackInstances && !force && this.sources[source]) {
        console.warn("[portal-vue]: source ".concat(source, " already exists"));
      }

      this.$set(this.sources, source, Object.freeze([vm]));
    },
    unregisterSource: function unregisterSource(source) {
      this.$delete(this.sources, source);
    },
    hasTarget: function hasTarget(to) {
      return !!(this.targets[to] && this.targets[to][0]);
    },
    hasSource: function hasSource(to) {
      return !!(this.sources[to] && this.sources[to][0]);
    },
    hasContentFor: function hasContentFor(to) {
      return !!this.transports[to] && !!this.transports[to].length;
    },
    // Internal
    $_getTransportIndex: function $_getTransportIndex(_ref) {
      var to = _ref.to,
          from = _ref.from;

      for (var i in this.transports[to]) {
        if (this.transports[to][i].from === from) {
          return +i;
        }
      }

      return -1;
    }
  }
});
var wormhole = new Wormhole(transports);

var _id = 1;
var Portal = Vue.extend({
  name: 'portal',
  props: {
    disabled: {
      type: Boolean
    },
    name: {
      type: String,
      default: function _default() {
        return String(_id++);
      }
    },
    order: {
      type: Number,
      default: 0
    },
    slim: {
      type: Boolean
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'DIV'
    },
    to: {
      type: String,
      default: function _default() {
        return String(Math.round(Math.random() * 10000000));
      }
    }
  },
  created: function created() {
    var _this = this;

    this.$nextTick(function () {
      wormhole.registerSource(_this.name, _this);
    });
  },
  mounted: function mounted() {
    if (!this.disabled) {
      this.sendUpdate();
    }
  },
  updated: function updated() {
    if (this.disabled) {
      this.clear();
    } else {
      this.sendUpdate();
    }
  },
  beforeDestroy: function beforeDestroy() {
    wormhole.unregisterSource(this.name);
    this.clear();
  },
  watch: {
    to: function to(newValue, oldValue) {
      oldValue && oldValue !== newValue && this.clear(oldValue);
      this.sendUpdate();
    }
  },
  methods: {
    clear: function clear(target) {
      var closer = {
        from: this.name,
        to: target || this.to
      };
      wormhole.close(closer);
    },
    normalizeSlots: function normalizeSlots() {
      return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;
    },
    normalizeOwnChildren: function normalizeOwnChildren(children) {
      return typeof children === 'function' ? children(this.slotProps) : children;
    },
    sendUpdate: function sendUpdate() {
      var slotContent = this.normalizeSlots();

      if (slotContent) {
        var transport = {
          from: this.name,
          to: this.to,
          passengers: _toConsumableArray(slotContent),
          order: this.order
        };
        wormhole.open(transport);
      } else {
        this.clear();
      }
    }
  },
  render: function render(h) {
    var children = this.$slots.default || this.$scopedSlots.default || [];
    var Tag = this.tag;

    if (children && this.disabled) {
      return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);
    } else {
      return this.slim ? h() : h(Tag, {
        class: {
          'v-portal': true
        },
        style: {
          display: 'none'
        },
        key: 'v-portal-placeholder'
      });
    }
  }
});

var PortalTarget = Vue.extend({
  name: 'portalTarget',
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      required: true
    },
    slim: {
      type: Boolean,
      default: false
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: [String, Object, Function]
    }
  },
  data: function data() {
    return {
      transports: wormhole.transports,
      firstRender: true
    };
  },
  created: function created() {
    var _this = this;

    this.$nextTick(function () {
      wormhole.registerTarget(_this.name, _this);
    });
  },
  watch: {
    ownTransports: function ownTransports() {
      this.$emit('change', this.children().length > 0);
    },
    name: function name(newVal, oldVal) {
      /**
       * TODO
       * This should warn as well ...
       */
      wormhole.unregisterTarget(oldVal);
      wormhole.registerTarget(newVal, this);
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    if (this.transition) {
      this.$nextTick(function () {
        // only when we have a transition, because it causes a re-render
        _this2.firstRender = false;
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    wormhole.unregisterTarget(this.name);
  },
  computed: {
    ownTransports: function ownTransports() {
      var transports = this.transports[this.name] || [];

      if (this.multiple) {
        return transports;
      }

      return transports.length === 0 ? [] : [transports[transports.length - 1]];
    },
    passengers: function passengers() {
      return combinePassengers(this.ownTransports, this.slotProps);
    }
  },
  methods: {
    // can't be a computed prop because it has to "react" to $slot changes.
    children: function children() {
      return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];
    },
    // can't be a computed prop because it has to "react" to this.children().
    noWrapper: function noWrapper() {
      var noWrapper = this.slim && !this.transition;

      if (noWrapper && this.children().length > 1) {
        console.warn('[portal-vue]: PortalTarget with `slim` option received more than one child element.');
      }

      return noWrapper;
    }
  },
  render: function render(h) {
    var noWrapper = this.noWrapper();
    var children = this.children();
    var Tag = this.transition || this.tag;
    return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {
      props: {
        // if we have a transition component, pass the tag if it exists
        tag: this.transition && this.tag ? this.tag : undefined
      },
      class: {
        'vue-portal-target': true
      }
    }, children);
  }
});

var _id$1 = 0;
var portalProps = ['disabled', 'name', 'order', 'slim', 'slotProps', 'tag', 'to'];
var targetProps = ['multiple', 'transition'];
var MountingPortal = Vue.extend({
  name: 'MountingPortal',
  inheritAttrs: false,
  props: {
    append: {
      type: [Boolean, String]
    },
    bail: {
      type: Boolean
    },
    mountTo: {
      type: String,
      required: true
    },
    // Portal
    disabled: {
      type: Boolean
    },
    // name for the portal
    name: {
      type: String,
      default: function _default() {
        return 'mounted_' + String(_id$1++);
      }
    },
    order: {
      type: Number,
      default: 0
    },
    slim: {
      type: Boolean
    },
    slotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    tag: {
      type: String,
      default: 'DIV'
    },
    // name for the target
    to: {
      type: String,
      default: function _default() {
        return String(Math.round(Math.random() * 10000000));
      }
    },
    // Target
    multiple: {
      type: Boolean,
      default: false
    },
    targetSlim: {
      type: Boolean
    },
    targetSlotProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    targetTag: {
      type: String,
      default: 'div'
    },
    transition: {
      type: [String, Object, Function]
    }
  },
  created: function created() {
    if (typeof document === 'undefined') { return; }
    var el = document.querySelector(this.mountTo);

    if (!el) {
      console.error("[portal-vue]: Mount Point '".concat(this.mountTo, "' not found in document"));
      return;
    }

    var props = this.$props; // Target already exists

    if (wormhole.targets[props.name]) {
      if (props.bail) {
        console.warn("[portal-vue]: Target ".concat(props.name, " is already mounted.\n        Aborting because 'bail: true' is set"));
      } else {
        this.portalTarget = wormhole.targets[props.name];
      }

      return;
    }

    var append = props.append;

    if (append) {
      var type = typeof append === 'string' ? append : 'DIV';
      var mountEl = document.createElement(type);
      el.appendChild(mountEl);
      el = mountEl;
    } // get props for target from $props
    // we have to rename a few of them


    var _props = pick(this.$props, targetProps);

    _props.slim = this.targetSlim;
    _props.tag = this.targetTag;
    _props.slotProps = this.targetSlotProps;
    _props.name = this.to;
    this.portalTarget = new PortalTarget({
      el: el,
      parent: this.$parent || this,
      propsData: _props
    });
  },
  beforeDestroy: function beforeDestroy() {
    var target = this.portalTarget;

    if (this.append) {
      var el = target.$el;
      el.parentNode.removeChild(el);
    }

    target.$destroy();
  },
  render: function render(h) {
    if (!this.portalTarget) {
      console.warn("[portal-vue] Target wasn't mounted");
      return h();
    } // if there's no "manual" scoped slot, so we create a <Portal> ourselves


    if (!this.$scopedSlots.manual) {
      var props = pick(this.$props, portalProps);
      return h(Portal, {
        props: props,
        attrs: this.$attrs,
        on: this.$listeners,
        scopedSlots: this.$scopedSlots
      }, this.$slots.default);
    } // else, we render the scoped slot


    var content = this.$scopedSlots.manual({
      to: this.to
    }); // if user used <template> for the scoped slot
    // content will be an array

    if (Array.isArray(content)) {
      content = content[0];
    }

    if (!content) { return h(); }
    return content;
  }
});

var ACTIVE_CLASS = 'active';
var IN_CLASS = 'in';

var script$3 = {
  components: { Portal: Portal },
  props: {
    title: {
      type: String,
      default: 'Tab Title'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    tabClasses: {
      type: Object,
      default: function () { return {} }
    },
    group: String,
    pullRight: {
      type: Boolean,
      default: false
    },
    hidden: {
      type: Boolean,
      default: false
    }
  },
  data: function data () {
    return {
      active: true,
      transition: 150
    }
  },
  watch: {
    active: function active (active$1) {
      var this$1 = this;

      if (active$1) {
        setTimeout(function () {
          addClass(this$1.$el, ACTIVE_CLASS);
          this$1.$el.offsetHeight;
          addClass(this$1.$el, IN_CLASS);
          try {
            this$1.$parent.$emit('changed', this$1.$parent.activeIndex);
          } catch (e) {
            throw new Error('<tab> parent must be <tabs>.')
          }
        }, this.transition);
      } else {
        removeClass(this.$el, IN_CLASS);
        setTimeout(function () {
          removeClass(this$1.$el, ACTIVE_CLASS);
        }, this.transition);
      }
    }
  },
  created: function created () {
    try {
      this.$parent.tabs.push(this);
    } catch (e) {
      throw new Error('<tab> parent must be <tabs>.')
    }
  },
  beforeDestroy: function beforeDestroy () {
    var tabs = this.$parent && this.$parent.tabs;
    spliceIfExist(tabs, this);
  },
  methods: {
    show: function show () {
      var this$1 = this;

      this.$nextTick(function () {
        addClass(this$1.$el, ACTIVE_CLASS);
        addClass(this$1.$el, IN_CLASS);
      });
    }
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */
var __vue_render__$3 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      staticClass: "tab-pane",
      class: { fade: _vm.transition > 0 },
      attrs: { role: "tabpanel" }
    },
    [
      _vm._t("default"),
      _vm._v(" "),
      _c("portal", { attrs: { to: _vm._uid.toString() } }, [_vm._t("title")], 2)
    ],
    2
  )
};
var __vue_staticRenderFns__$3 = [];
__vue_render__$3._withStripped = true;

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$3 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    false,
    undefined,
    undefined,
    undefined
  );

var BEFORE_CHANGE_EVENT = 'before-change';

var script$4 = {
  components: { Dropdown: Dropdown, PortalTarget: PortalTarget },
  props: {
    value: {
      type: Number,
      validator: function (v) { return v >= 0; }
    },
    transition: {
      type: Number,
      default: 150
    },
    justified: Boolean,
    pills: Boolean,
    stacked: Boolean,
    customNavClass: null,
    customContentClass: null
  },
  data: function data () {
    return {
      tabs: [],
      activeIndex: 0 // Make v-model not required
    }
  },
  watch: {
    value: {
      immediate: true,
      handler: function handler (value) {
        if (isNumber(value)) {
          this.activeIndex = value;
          this.selectCurrent();
        }
      }
    },
    tabs: function tabs (tabs$1) {
      var this$1 = this;

      tabs$1.forEach(function (tab, index) {
        tab.transition = this$1.transition;
        if (index === this$1.activeIndex) {
          tab.show();
        }
      });
      this.selectCurrent();
    }
  },
  computed: {
    navClasses: function navClasses () {
      var obj;

      var tabClasses = {
        nav: true,
        'nav-justified': this.justified,
        'nav-tabs': !this.pills,
        'nav-pills': this.pills,
        'nav-stacked': this.stacked && this.pills
      };
      var customNavClass = this.customNavClass;
      if (isExist(customNavClass)) {
        if (isString(customNavClass)) {
          return assign({}, tabClasses, ( obj = {}, obj[customNavClass] = true, obj ))
        } else {
          return assign({}, tabClasses, customNavClass)
        }
      } else {
        return tabClasses
      }
    },
    contentClasses: function contentClasses () {
      var obj;

      var contentClasses = {
        'tab-content': true
      };
      var customContentClass = this.customContentClass;
      if (isExist(customContentClass)) {
        if (isString(customContentClass)) {
          return assign({}, contentClasses, ( obj = {}, obj[customContentClass] = true, obj ))
        } else {
          return assign({}, contentClasses, customContentClass)
        }
      } else {
        return contentClasses
      }
    },
    groupedTabs: function groupedTabs () {
      var tabs = [];
      var hash = {};
      this.tabs.forEach(function (tab) {
        if (tab.group) {
          if (hasOwnProperty(hash, tab.group)) {
            tabs[hash[tab.group]].tabs.push(tab);
          } else {
            tabs.push({
              tabs: [tab],
              group: tab.group
            });
            hash[tab.group] = tabs.length - 1;
          }
          if (tab.active) {
            tabs[hash[tab.group]].active = true;
          }
          if (tab.pullRight) {
            tabs[hash[tab.group]].pullRight = true;
          }
        } else {
          tabs.push(tab);
        }
      });
      tabs = tabs.map(function (tab) {
        if (Array.isArray(tab.tabs)) {
          tab.hidden = tab.tabs.filter(function (v) { return v.hidden; }).length === tab.tabs.length;
        }
        return tab
      });
      return tabs
    }
  },
  methods: {
    getTabClasses: function getTabClasses (tab, isSubTab) {
      if ( isSubTab === void 0 ) isSubTab = false;

      var defaultClasses = {
        active: tab.active,
        disabled: tab.disabled,
        'pull-right': tab.pullRight && !isSubTab
      };

      // return with new classes added to tab
      return assign(defaultClasses, tab.tabClasses)
    },
    selectCurrent: function selectCurrent () {
      var this$1 = this;

      var found = false;
      this.tabs.forEach(function (tab, index) {
        if (index === this$1.activeIndex) {
          found = !tab.active;
          tab.active = true;
        } else {
          tab.active = false;
        }
      });
      if (found) {
        this.$emit('change', this.activeIndex);
      }
    },
    selectValidate: function selectValidate (index) {
      var this$1 = this;

      if (isFunction(this.$listeners[BEFORE_CHANGE_EVENT])) {
        this.$emit(BEFORE_CHANGE_EVENT, this.activeIndex, index, function (result) {
          if (!isExist(result)) {
            this$1.$select(index);
          }
        });
      } else {
        this.$select(index);
      }
    },
    select: function select (index) {
      if (!this.tabs[index].disabled && index !== this.activeIndex) {
        this.selectValidate(index);
      }
    },
    $select: function $select (index) {
      if (isNumber(this.value)) {
        this.$emit('input', index);
      } else {
        this.activeIndex = index;
        this.selectCurrent();
      }
    }
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */
var __vue_render__$4 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("section", [
    _c(
      "ul",
      { class: _vm.navClasses, attrs: { role: "tablist" } },
      [
        _vm._l(_vm.groupedTabs, function(tab, index) {
          return [
            tab.tabs
              ? _c(
                  "dropdown",
                  {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: !tab.hidden,
                        expression: "!tab.hidden"
                      }
                    ],
                    class: _vm.getTabClasses(tab),
                    attrs: { role: "presentation", tag: "li" }
                  },
                  [
                    _c(
                      "a",
                      {
                        staticClass: "dropdown-toggle",
                        attrs: { role: "tab", href: "#" },
                        on: {
                          click: function($event) {
                            $event.preventDefault();
                          }
                        }
                      },
                      [
                        _vm._v(_vm._s(tab.group) + " "),
                        _c("span", { staticClass: "caret" })
                      ]
                    ),
                    _vm._v(" "),
                    _c(
                      "template",
                      { slot: "dropdown" },
                      _vm._l(tab.tabs, function(subTab) {
                        return _c(
                          "li",
                          {
                            directives: [
                              {
                                name: "show",
                                rawName: "v-show",
                                value: !subTab.hidden,
                                expression: "!subTab.hidden"
                              }
                            ],
                            class: _vm.getTabClasses(subTab, true)
                          },
                          [
                            _c(
                              "a",
                              {
                                attrs: { href: "#" },
                                on: {
                                  click: function($event) {
                                    $event.preventDefault();
                                    _vm.select(_vm.tabs.indexOf(subTab));
                                  }
                                }
                              },
                              [_vm._v(_vm._s(subTab.title))]
                            )
                          ]
                        )
                      }),
                      0
                    )
                  ],
                  2
                )
              : _c(
                  "li",
                  {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: !tab.hidden,
                        expression: "!tab.hidden"
                      }
                    ],
                    class: _vm.getTabClasses(tab),
                    attrs: { role: "presentation" }
                  },
                  [
                    tab.$slots.title
                      ? _c(
                          "a",
                          {
                            attrs: { role: "tab", href: "#" },
                            on: {
                              click: function($event) {
                                $event.preventDefault();
                                _vm.select(_vm.tabs.indexOf(tab));
                              }
                            }
                          },
                          [
                            _c("portal-target", {
                              attrs: { name: tab._uid.toString() }
                            })
                          ],
                          1
                        )
                      : _c("a", {
                          attrs: { role: "tab", href: "#" },
                          domProps: { textContent: _vm._s(tab.title) },
                          on: {
                            click: function($event) {
                              $event.preventDefault();
                              _vm.select(_vm.tabs.indexOf(tab));
                            }
                          }
                        })
                  ]
                )
          ]
        }),
        _vm._v(" "),
        !_vm.justified && _vm.$slots["nav-right"]
          ? _c("li", { staticClass: "pull-right" }, [_vm._t("nav-right")], 2)
          : _vm._e()
      ],
      2
    ),
    _vm._v(" "),
    _c("div", { class: _vm.contentClasses }, [_vm._t("default")], 2)
  ])
};
var __vue_staticRenderFns__$4 = [];
__vue_render__$4._withStripped = true;

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$4 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    false,
    undefined,
    undefined,
    undefined
  );

function pad (value, num) {
  value = value + '';
  for (var i = num - value.length; i > 0; i--) {
    value = '0' + value;
  }
  return value
}

var monthNames = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'November',
  'December'
];

/**
 * Get total days number in a month.
 * because we're using 0 as the day so that it returns the last day
 * of the last month, so you have to add 1 to the month number
 * so it returns the correct amount of days.
 * https://stackoverflow.com/questions/1184334/get-number-days-in-a-specified-month-using-javascript
 * @param month 0-based
 * @param year
 * @returns {number}
 */
function daysInMonth (month, year) {
  return new Date(year, month + 1, 0).getDate()
}

function stringify (date, format) {
  try {
    var year = date.getFullYear();
    var month = date.getMonth() + 1;
    var day = date.getDate();
    var monthName = monthNames[month - 1];
    return format
      .replace(/yyyy/g, year)
      .replace(/MMMM/g, monthName)
      .replace(/MMM/g, monthName.substring(0, 3))
      .replace(/MM/g, pad(month, 2))
      .replace(/dd/g, pad(day, 2))
      .replace(/yy/g, year)
      .replace(/M(?!a)/g, month)
      .replace(/d/g, day)
  } catch (e) {
    return ''
  }
}

function convertDateToUTC (date) {
  return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds())
}

/**
 * https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php
 * For a given date, get the ISO week number
 * Based on information at:
 *    http://www.merlyn.demon.co.uk/weekcalc.htm#WNR
 *
 * Algorithm is to find nearest thursday, it's year
 * is the year of the week number. Then get weeks
 * between that date and the first day of that year.
 *
 * Note that dates in one year can be weeks of previous
 * or next year, overlap is up to 3 days.
 *
 * e.g. 2014/12/29 is Monday in week  1 of 2015
 *      2012/1/1   is Sunday in week 52 of 2011
 *
 * @param {number} d.year year of date
 * @param {number} d.month month of date
 * @param {number} d.date date of date
 * @returns {number}
 */
function getWeekNumber (d) {
  // Copy date so don't modify original
  var _d = new Date(Date.UTC(d.year, d.month, d.date));
  // Set to nearest Thursday: current date + 4 - current day number
  // Make Sunday's day number 7
  _d.setUTCDate(_d.getUTCDate() + 4 - (_d.getUTCDay() || 7));
  // Get first day of year
  var yearStart = new Date(Date.UTC(_d.getUTCFullYear(), 0, 1));
  // Calculate full weeks to nearest Thursday
  return Math.ceil((((_d - yearStart) / 86400000) + 1) / 7)
}

var script$5 = {
  mixins: [Local],
  props: {
    month: Number,
    year: Number,
    date: Date,
    today: Date,
    limit: Object,
    weekStartsWith: Number,
    iconControlLeft: String,
    iconControlRight: String,
    dateClass: Function,
    yearMonthFormatter: Function,
    weekNumbers: Boolean
  },
  components: { Btn: Btn },
  computed: {
    weekDays: function weekDays () {
      var days = [];
      var firstDay = this.weekStartsWith;
      while (days.length < 7) {
        days.push(firstDay++);
        if (firstDay > 6) {
          firstDay = 0;
        }
      }
      return days
    },
    yearMonthStr: function yearMonthStr () {
      if (this.yearMonthFormatter) {
        return this.yearMonthFormatter(this.year, this.month)
      } else {
        return isExist(this.month) ? ((this.year) + " " + (this.t(("uiv.datePicker.month" + (this.month + 1))))) : this.year
      }
    },
    monthDayRows: function monthDayRows () {
      var rows = [];
      var firstDay = new Date(this.year, this.month, 1);
      var prevMonthLastDate = new Date(this.year, this.month, 0).getDate();
      var startIndex = firstDay.getDay();
      // console.log(startIndex)
      var daysNum = daysInMonth(this.month, this.year);
      var weekOffset = 0;
      if (this.weekStartsWith > startIndex) {
        weekOffset = 7 - this.weekStartsWith;
      } else {
        weekOffset = 0 - this.weekStartsWith;
      }
      // console.log(prevMonthLastDate, startIndex, daysNum)
      for (var i = 0; i < 6; i++) {
        rows.push([]);
        for (var j = 0 - weekOffset; j < 7 - weekOffset; j++) {
          var currentIndex = i * 7 + j;
          var date = { year: this.year, disabled: false };
          // date in and not in current month
          if (currentIndex < startIndex) {
            date.date = prevMonthLastDate - startIndex + currentIndex + 1;
            if (this.month > 0) {
              date.month = this.month - 1;
            } else {
              date.month = 11;
              date.year--;
            }
          } else if (currentIndex < startIndex + daysNum) {
            date.date = currentIndex - startIndex + 1;
            date.month = this.month;
          } else {
            date.date = currentIndex - startIndex - daysNum + 1;
            if (this.month < 11) {
              date.month = this.month + 1;
            } else {
              date.month = 0;
              date.year++;
            }
          }
          // process limit dates
          var dateObj = new Date(date.year, date.month, date.date);
          var afterFrom = true;
          var beforeTo = true;
          if (this.limit && this.limit.from) {
            afterFrom = dateObj >= this.limit.from;
          }
          if (this.limit && this.limit.to) {
            beforeTo = dateObj < this.limit.to;
          }
          date.disabled = !afterFrom || !beforeTo;
          if (isFunction(this.dateClass)) {
            date.classes = this.dateClass(dateObj, {
              currentMonth: this.month,
              currentYear: this.year
            });
          } else {
            date.classes = '';
          }
          rows[i].push(date);
        }
      }
      return rows
    }
  },
  methods: {
    getWeekNumber: getWeekNumber,
    tWeekName: function tWeekName (index) {
      return this.t(("uiv.datePicker.week" + index))
    },
    getBtnType: function getBtnType (date) {
      if (this.date &&
        date.date === this.date.getDate() &&
        date.month === this.date.getMonth() &&
        date.year === this.date.getFullYear()) {
        return 'primary'
      } else if (date.date === this.today.getDate() &&
        date.month === this.today.getMonth() &&
        date.year === this.today.getFullYear()) {
        return 'info'
      } else {
        return 'default'
      }
    },
    select: function select (date) {
      this.$emit('date-change', date);
    },
    goPrevMonth: function goPrevMonth () {
      var month = this.month;
      var year = this.year;
      if (this.month > 0) {
        month--;
      } else {
        month = 11;
        year--;
        this.$emit('year-change', year);
      }
      this.$emit('month-change', month);
    },
    goNextMonth: function goNextMonth () {
      var month = this.month;
      var year = this.year;
      if (this.month < 11) {
        month++;
      } else {
        month = 0;
        year++;
        this.$emit('year-change', year);
      }
      this.$emit('month-change', month);
    },
    changeView: function changeView () {
      this.$emit('view-change', 'm');
    }
  }
};

/* script */
var __vue_script__$5 = script$5;

/* template */
var __vue_render__$5 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "table",
    { staticStyle: { width: "100%" }, attrs: { role: "grid" } },
    [
      _c("thead", [
        _c("tr", [
          _c(
            "td",
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-pager-prev",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.goPrevMonth }
                },
                [_c("i", { class: _vm.iconControlLeft })]
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "td",
            { attrs: { colspan: _vm.weekNumbers ? 6 : 5 } },
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-title",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.changeView }
                },
                [_c("b", [_vm._v(_vm._s(_vm.yearMonthStr))])]
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "td",
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-pager-next",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.goNextMonth }
                },
                [_c("i", { class: _vm.iconControlRight })]
              )
            ],
            1
          )
        ]),
        _vm._v(" "),
        _c(
          "tr",
          { attrs: { align: "center" } },
          [
            _vm.weekNumbers ? _c("td") : _vm._e(),
            _vm._v(" "),
            _vm._l(_vm.weekDays, function(day) {
              return _c("td", { attrs: { width: "14.2857142857%" } }, [
                _c("small", { staticClass: "uiv-datepicker-week" }, [
                  _vm._v(_vm._s(_vm.tWeekName(day === 0 ? 7 : day)))
                ])
              ])
            })
          ],
          2
        )
      ]),
      _vm._v(" "),
      _c(
        "tbody",
        _vm._l(_vm.monthDayRows, function(row) {
          return _c(
            "tr",
            [
              _vm.weekNumbers
                ? _c(
                    "td",
                    {
                      staticClass: "text-center",
                      staticStyle: { "border-right": "1px solid #eee" }
                    },
                    [
                      _c("small", { staticClass: "text-muted" }, [
                        _vm._v(
                          _vm._s(_vm.getWeekNumber(row[_vm.weekStartsWith]))
                        )
                      ])
                    ]
                  )
                : _vm._e(),
              _vm._v(" "),
              _vm._l(row, function(date) {
                return _c(
                  "td",
                  [
                    _c(
                      "btn",
                      {
                        class: date.classes,
                        staticStyle: { border: "none" },
                        attrs: {
                          block: "",
                          size: "sm",
                          "data-action": "select",
                          type: _vm.getBtnType(date),
                          disabled: date.disabled
                        },
                        on: {
                          click: function($event) {
                            return _vm.select(date)
                          }
                        }
                      },
                      [
                        _c(
                          "span",
                          {
                            class: { "text-muted": _vm.month !== date.month },
                            attrs: { "data-action": "select" }
                          },
                          [_vm._v(_vm._s(date.date))]
                        )
                      ]
                    )
                  ],
                  1
                )
              })
            ],
            2
          )
        }),
        0
      )
    ]
  )
};
var __vue_staticRenderFns__$5 = [];
__vue_render__$5._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$5 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    false,
    undefined,
    undefined,
    undefined
  );

var script$6 = {
  components: { Btn: Btn },
  mixins: [Local],
  props: {
    month: Number,
    year: Number,
    iconControlLeft: String,
    iconControlRight: String
  },
  data: function data () {
    return {
      rows: []
    }
  },
  mounted: function mounted () {
    for (var i = 0; i < 4; i++) {
      this.rows.push([]);
      for (var j = 0; j < 3; j++) {
        this.rows[i].push(i * 3 + j + 1);
      }
    }
  },
  methods: {
    tCell: function tCell (cell) {
      return this.t(("uiv.datePicker.month" + cell))
    },
    getBtnClass: function getBtnClass (month) {
      if (month === this.month) {
        return 'primary'
      } else {
        return 'default'
      }
    },
    goPrevYear: function goPrevYear () {
      this.$emit('year-change', this.year - 1);
    },
    goNextYear: function goNextYear () {
      this.$emit('year-change', this.year + 1);
    },
    changeView: function changeView (monthIndex) {
      if (isExist(monthIndex)) {
        this.$emit('month-change', monthIndex);
        this.$emit('view-change', 'd');
      } else {
        this.$emit('view-change', 'y');
      }
    }
  }
};

/* script */
var __vue_script__$6 = script$6;

/* template */
var __vue_render__$6 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "table",
    { staticStyle: { width: "100%" }, attrs: { role: "grid" } },
    [
      _c("thead", [
        _c("tr", [
          _c(
            "td",
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-pager-prev",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.goPrevYear }
                },
                [_c("i", { class: _vm.iconControlLeft })]
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "td",
            { attrs: { colspan: "4" } },
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-title",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: {
                    click: function($event) {
                      return _vm.changeView()
                    }
                  }
                },
                [_c("b", [_vm._v(_vm._s(_vm.year))])]
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "td",
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-pager-next",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.goNextYear }
                },
                [_c("i", { class: _vm.iconControlRight })]
              )
            ],
            1
          )
        ])
      ]),
      _vm._v(" "),
      _c(
        "tbody",
        _vm._l(_vm.rows, function(row, i) {
          return _c(
            "tr",
            _vm._l(row, function(month, j) {
              return _c(
                "td",
                { attrs: { colspan: "2", width: "33.333333%" } },
                [
                  _c(
                    "btn",
                    {
                      staticStyle: { border: "none" },
                      attrs: {
                        block: "",
                        size: "sm",
                        type: _vm.getBtnClass(i * 3 + j)
                      },
                      on: {
                        click: function($event) {
                          return _vm.changeView(i * 3 + j)
                        }
                      }
                    },
                    [_c("span", [_vm._v(_vm._s(_vm.tCell(month)))])]
                  )
                ],
                1
              )
            }),
            0
          )
        }),
        0
      )
    ]
  )
};
var __vue_staticRenderFns__$6 = [];
__vue_render__$6._withStripped = true;

  /* style */
  var __vue_inject_styles__$6 = undefined;
  /* scoped */
  var __vue_scope_id__$6 = undefined;
  /* module identifier */
  var __vue_module_identifier__$6 = undefined;
  /* functional template */
  var __vue_is_functional_template__$6 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$6 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
    __vue_inject_styles__$6,
    __vue_script__$6,
    __vue_scope_id__$6,
    __vue_is_functional_template__$6,
    __vue_module_identifier__$6,
    false,
    undefined,
    undefined,
    undefined
  );

var script$7 = {
  components: { Btn: Btn },
  props: {
    year: Number,
    iconControlLeft: String,
    iconControlRight: String
  },
  computed: {
    rows: function rows () {
      var rows = [];
      var yearGroupStart = this.year - this.year % 20;
      for (var i = 0; i < 4; i++) {
        rows.push([]);
        for (var j = 0; j < 5; j++) {
          rows[i].push(yearGroupStart + i * 5 + j);
        }
      }
      return rows
    },
    yearStr: function yearStr () {
      var start = this.year - this.year % 20;
      return (start + " ~ " + (start + 19))
    }
  },
  methods: {
    getBtnClass: function getBtnClass (year) {
      if (year === this.year) {
        return 'primary'
      } else {
        return 'default'
      }
    },
    goPrevYear: function goPrevYear () {
      this.$emit('year-change', this.year - 20);
    },
    goNextYear: function goNextYear () {
      this.$emit('year-change', this.year + 20);
    },
    changeView: function changeView (year) {
      this.$emit('year-change', year);
      this.$emit('view-change', 'm');
    }
  }
};

/* script */
var __vue_script__$7 = script$7;

/* template */
var __vue_render__$7 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "table",
    { staticStyle: { width: "100%" }, attrs: { role: "grid" } },
    [
      _c("thead", [
        _c("tr", [
          _c(
            "td",
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-pager-prev",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.goPrevYear }
                },
                [_c("i", { class: _vm.iconControlLeft })]
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "td",
            { attrs: { colspan: "3" } },
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-title",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" }
                },
                [_c("b", [_vm._v(_vm._s(_vm.yearStr))])]
              )
            ],
            1
          ),
          _vm._v(" "),
          _c(
            "td",
            [
              _c(
                "btn",
                {
                  staticClass: "uiv-datepicker-pager-next",
                  staticStyle: { border: "none" },
                  attrs: { block: "", size: "sm" },
                  on: { click: _vm.goNextYear }
                },
                [_c("i", { class: _vm.iconControlRight })]
              )
            ],
            1
          )
        ])
      ]),
      _vm._v(" "),
      _c(
        "tbody",
        _vm._l(_vm.rows, function(row) {
          return _c(
            "tr",
            _vm._l(row, function(year) {
              return _c(
                "td",
                { attrs: { width: "20%" } },
                [
                  _c(
                    "btn",
                    {
                      staticStyle: { border: "none" },
                      attrs: {
                        block: "",
                        size: "sm",
                        type: _vm.getBtnClass(year)
                      },
                      on: {
                        click: function($event) {
                          return _vm.changeView(year)
                        }
                      }
                    },
                    [_c("span", [_vm._v(_vm._s(year))])]
                  )
                ],
                1
              )
            }),
            0
          )
        }),
        0
      )
    ]
  )
};
var __vue_staticRenderFns__$7 = [];
__vue_render__$7._withStripped = true;

  /* style */
  var __vue_inject_styles__$7 = undefined;
  /* scoped */
  var __vue_scope_id__$7 = undefined;
  /* module identifier */
  var __vue_module_identifier__$7 = undefined;
  /* functional template */
  var __vue_is_functional_template__$7 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$7 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
    __vue_inject_styles__$7,
    __vue_script__$7,
    __vue_scope_id__$7,
    __vue_is_functional_template__$7,
    __vue_module_identifier__$7,
    false,
    undefined,
    undefined,
    undefined
  );

var script$8 = {
  mixins: [Local],
  components: { DateView: __vue_component__$5, MonthView: __vue_component__$6, YearView: __vue_component__$7, Btn: Btn },
  props: {
    value: null,
    width: {
      type: Number,
      default: 270
    },
    todayBtn: {
      type: Boolean,
      default: true
    },
    clearBtn: {
      type: Boolean,
      default: true
    },
    closeOnSelected: {
      type: Boolean,
      default: true
    },
    limitFrom: null,
    limitTo: null,
    format: {
      type: String,
      default: 'yyyy-MM-dd'
    },
    initialView: {
      type: String,
      default: 'd'
    },
    dateParser: {
      type: Function,
      default: Date.parse
    },
    dateClass: Function,
    yearMonthFormatter: Function,
    weekStartsWith: {
      type: Number,
      default: 0,
      validator: function validator (value) {
        return value >= 0 && value <= 6
      }
    },
    weekNumbers: Boolean,
    iconControlLeft: {
      type: String,
      default: 'glyphicon glyphicon-chevron-left'
    },
    iconControlRight: {
      type: String,
      default: 'glyphicon glyphicon-chevron-right'
    }
  },
  data: function data () {
    return {
      show: false,
      now: new Date(),
      currentMonth: 0,
      currentYear: 0,
      view: 'd'
    }
  },
  computed: {
    valueDateObj: function valueDateObj () {
      var ts = this.dateParser(this.value);
      if (isNaN(ts)) {
        return null
      } else {
        var date = new Date(ts);
        if (date.getHours() !== 0) {
          date = new Date(ts + date.getTimezoneOffset() * 60 * 1000);
        }
        return date
      }
    },
    pickerStyle: function pickerStyle () {
      return {
        width: this.width + 'px'
      }
    },
    pickerClass: function pickerClass () {
      return {
        'uiv-datepicker': true,
        'uiv-datepicker-date': this.view === 'd',
        'uiv-datepicker-month': this.view === 'm',
        'uiv-datepicker-year': this.view === 'y'
      }
    },
    limit: function limit () {
      var limit = {};
      if (this.limitFrom) {
        var limitFrom = this.dateParser(this.limitFrom);
        if (!isNaN(limitFrom)) {
          limitFrom = convertDateToUTC(new Date(limitFrom));
          limitFrom.setHours(0, 0, 0, 0);
          limit.from = limitFrom;
        }
      }
      if (this.limitTo) {
        var limitTo = this.dateParser(this.limitTo);
        if (!isNaN(limitTo)) {
          limitTo = convertDateToUTC(new Date(limitTo));
          limitTo.setHours(0, 0, 0, 0);
          limit.to = limitTo;
        }
      }
      return limit
    }
  },
  mounted: function mounted () {
    if (this.value) {
      this.setMonthAndYearByValue(this.value);
    } else {
      this.currentMonth = this.now.getMonth();
      this.currentYear = this.now.getFullYear();
      this.view = this.initialView;
    }
  },
  watch: {
    value: function value (val, oldVal) {
      this.setMonthAndYearByValue(val, oldVal);
    }
  },
  methods: {
    setMonthAndYearByValue: function setMonthAndYearByValue (val, oldVal) {
      var ts = this.dateParser(val);
      if (!isNaN(ts)) {
        var date = new Date(ts);
        if (date.getHours() !== 0) {
          date = new Date(ts + date.getTimezoneOffset() * 60 * 1000);
        }
        if (this.limit && ((this.limit.from && date < this.limit.from) || (this.limit.to && date >= this.limit.to))) {
          this.$emit('input', oldVal || '');
        } else {
          this.currentMonth = date.getMonth();
          this.currentYear = date.getFullYear();
        }
      }
    },
    onMonthChange: function onMonthChange (month) {
      this.currentMonth = month;
    },
    onYearChange: function onYearChange (year) {
      this.currentYear = year;
      this.currentMonth = undefined;
    },
    onDateChange: function onDateChange (date) {
      if (date && isNumber(date.date) && isNumber(date.month) && isNumber(date.year)) {
        var _date = new Date(date.year, date.month, date.date);
        this.$emit('input', this.format ? stringify(_date, this.format) : _date);
        // if the input event trigger nothing (same value)
        // manually correct
        this.currentMonth = date.month;
        this.currentYear = date.year;
      } else {
        this.$emit('input', '');
      }
    },
    onViewChange: function onViewChange (view) {
      this.view = view;
    },
    selectToday: function selectToday () {
      this.view = 'd';
      this.onDateChange({
        date: this.now.getDate(),
        month: this.now.getMonth(),
        year: this.now.getFullYear()
      });
    },
    clearSelect: function clearSelect () {
      this.currentMonth = this.now.getMonth();
      this.currentYear = this.now.getFullYear();
      this.view = this.initialView;
      this.onDateChange();
    },
    onPickerClick: function onPickerClick (event) {
      if (event.target.getAttribute('data-action') !== 'select' || !this.closeOnSelected) {
        event.stopPropagation();
      }
    }
  }
};

/* script */
var __vue_script__$8 = script$8;

/* template */
var __vue_render__$8 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    {
      class: _vm.pickerClass,
      style: _vm.pickerStyle,
      attrs: { "data-role": "date-picker" },
      on: { click: _vm.onPickerClick }
    },
    [
      _c("date-view", {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.view === "d",
            expression: "view==='d'"
          }
        ],
        attrs: {
          month: _vm.currentMonth,
          year: _vm.currentYear,
          date: _vm.valueDateObj,
          today: _vm.now,
          limit: _vm.limit,
          "week-starts-with": _vm.weekStartsWith,
          "icon-control-left": _vm.iconControlLeft,
          "icon-control-right": _vm.iconControlRight,
          "date-class": _vm.dateClass,
          "year-month-formatter": _vm.yearMonthFormatter,
          "week-numbers": _vm.weekNumbers,
          locale: _vm.locale
        },
        on: {
          "month-change": _vm.onMonthChange,
          "year-change": _vm.onYearChange,
          "date-change": _vm.onDateChange,
          "view-change": _vm.onViewChange
        }
      }),
      _vm._v(" "),
      _c("month-view", {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.view === "m",
            expression: "view==='m'"
          }
        ],
        attrs: {
          month: _vm.currentMonth,
          year: _vm.currentYear,
          "icon-control-left": _vm.iconControlLeft,
          "icon-control-right": _vm.iconControlRight,
          locale: _vm.locale
        },
        on: {
          "month-change": _vm.onMonthChange,
          "year-change": _vm.onYearChange,
          "view-change": _vm.onViewChange
        }
      }),
      _vm._v(" "),
      _c("year-view", {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.view === "y",
            expression: "view==='y'"
          }
        ],
        attrs: {
          year: _vm.currentYear,
          "icon-control-left": _vm.iconControlLeft,
          "icon-control-right": _vm.iconControlRight
        },
        on: { "year-change": _vm.onYearChange, "view-change": _vm.onViewChange }
      }),
      _vm._v(" "),
      _vm.todayBtn || _vm.clearBtn
        ? _c("div", [
            _c("br"),
            _vm._v(" "),
            _c(
              "div",
              { staticClass: "text-center" },
              [
                _vm.todayBtn
                  ? _c("btn", {
                      attrs: {
                        "data-action": "select",
                        type: "info",
                        size: "sm"
                      },
                      domProps: {
                        textContent: _vm._s(_vm.t("uiv.datePicker.today"))
                      },
                      on: { click: _vm.selectToday }
                    })
                  : _vm._e(),
                _vm._v(" "),
                _vm.clearBtn
                  ? _c("btn", {
                      attrs: { "data-action": "select", size: "sm" },
                      domProps: {
                        textContent: _vm._s(_vm.t("uiv.datePicker.clear"))
                      },
                      on: { click: _vm.clearSelect }
                    })
                  : _vm._e()
              ],
              1
            )
          ])
        : _vm._e()
    ],
    1
  )
};
var __vue_staticRenderFns__$8 = [];
__vue_render__$8._withStripped = true;

  /* style */
  var __vue_inject_styles__$8 = undefined;
  /* scoped */
  var __vue_scope_id__$8 = undefined;
  /* module identifier */
  var __vue_module_identifier__$8 = undefined;
  /* functional template */
  var __vue_is_functional_template__$8 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$8 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
    __vue_inject_styles__$8,
    __vue_script__$8,
    __vue_scope_id__$8,
    __vue_is_functional_template__$8,
    __vue_module_identifier__$8,
    false,
    undefined,
    undefined,
    undefined
  );

var HANDLER = '_uiv_scroll_handler';
var events = [EVENTS.RESIZE, EVENTS.SCROLL];

var bind = function (el, binding) {
  var callback = binding.value;
  if (!isFunction(callback)) {
    return
  }
  unbind(el);
  el[HANDLER] = callback;
  events.forEach(function (event) {
    on(window, event, el[HANDLER]);
  });
};

var unbind = function (el) {
  events.forEach(function (event) {
    off(window, event, el[HANDLER]);
  });
  delete el[HANDLER];
};

var update = function (el, binding) {
  if (binding.value !== binding.oldValue) {
    bind(el, binding);
  }
};

var scroll = { bind: bind, unbind: unbind, update: update };

var script$9 = {
  directives: {
    scroll: scroll
  },
  props: {
    offset: {
      type: Number,
      default: 0
    }
  },
  data: function data () {
    return {
      affixed: false
    }
  },
  computed: {
    classes: function classes () {
      return {
        affix: this.affixed
      }
    },
    styles: function styles () {
      return {
        top: this.affixed ? this.offset + 'px' : null
      }
    }
  },
  methods: {
    // from https://github.com/ant-design/ant-design/blob/master/components/affix/index.jsx#L20
    onScroll: function onScroll () {
      var this$1 = this;

      // if is hidden don't calculate anything
      if (!(this.$el.offsetWidth || this.$el.offsetHeight || this.$el.getClientRects().length)) {
        return
      }
      // get window scroll and element position to detect if have to be normal or affixed
      var scroll = {};
      var element = {};
      var rect = this.$el.getBoundingClientRect();
      var body = document.body;
      var types = ['Top', 'Left'];
      types.forEach(function (type) {
        var t = type.toLowerCase();
        scroll[t] = window['page' + (type === 'Top' ? 'Y' : 'X') + 'Offset'];
        element[t] = scroll[t] + rect[t] - (this$1.$el['client' + type] || body['client' + type] || 0);
      });
      var fix = scroll.top > element.top - this.offset;
      if (this.affixed !== fix) {
        this.affixed = fix;
        this.$emit(this.affixed ? 'affix' : 'unfix');
        this.$nextTick(function () {
          this$1.$emit(this$1.affixed ? 'affixed' : 'unfixed');
        });
      }
    }
  }
};

/* script */
var __vue_script__$9 = script$9;

/* template */
var __vue_render__$9 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", { staticClass: "hidden-print" }, [
    _c(
      "div",
      {
        directives: [
          {
            name: "scroll",
            rawName: "v-scroll",
            value: _vm.onScroll,
            expression: "onScroll"
          }
        ],
        class: _vm.classes,
        style: _vm.styles
      },
      [_vm._t("default")],
      2
    )
  ])
};
var __vue_staticRenderFns__$9 = [];
__vue_render__$9._withStripped = true;

  /* style */
  var __vue_inject_styles__$9 = undefined;
  /* scoped */
  var __vue_scope_id__$9 = undefined;
  /* module identifier */
  var __vue_module_identifier__$9 = undefined;
  /* functional template */
  var __vue_is_functional_template__$9 = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$9 = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
    __vue_inject_styles__$9,
    __vue_script__$9,
    __vue_scope_id__$9,
    __vue_is_functional_template__$9,
    __vue_module_identifier__$9,
    false,
    undefined,
    undefined,
    undefined
  );

var script$a = {
  props: {
    dismissible: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 0
    },
    type: {
      type: String,
      default: 'info'
    }
  },
  data: function data () {
    return {
      timeout: 0
    }
  },
  computed: {
    alertClass: function alertClass () {
      var obj;

      return ( obj = {
        alert: true
      }, obj[("alert-" + (this.type))] = Boolean(this.type), obj['alert-dismissible'] = this.dismissible, obj )
    }
  },
  methods: {
    closeAlert: function closeAlert () {
      clearTimeout(this.timeout);
      this.$emit('dismissed');
    }
  },
  mounted: function mounted () {
    if (this.duration > 0) {
      this.timeout = setTimeout(this.closeAlert, this.duration);
    }
  },
  destroyed: function destroyed () {
    clearTimeout(this.timeout);
  }
};

/* script */
var __vue_script__$a = script$a;

/* template */
var __vue_render__$a = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "div",
    { class: _vm.alertClass, attrs: { role: "alert" } },
    [
      _vm.dismissible
        ? _c(
            "button",
            {
              staticClass: "close",
              attrs: { type: "button", "aria-label": "Close" },
              on: { click: _vm.closeAlert }
            },
            [_c("span", { attrs: { "aria-hidden": "true" } }, [_vm._v("")])]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm._t("default")
    ],
    2
  )
};
var __vue_staticRenderFns__$a = [];
__vue_render__$a._withStripped = true;

  /* style */
  var __vue_inject_styles__$a = undefined;
  /* scoped */
  var __vue_scope_id__$a = undefined;
  /* module identifier */
  var __vue_module_identifier__$a = undefined;
  /* functional template */
  var __vue_is_functional_template__$a = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$a = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
    __vue_inject_styles__$a,
    __vue_script__$a,
    __vue_scope_id__$a,
    __vue_is_functional_template__$a,
    __vue_module_identifier__$a,
    false,
    undefined,
    undefined,
    undefined
  );

var script$b = {
  props: {
    value: {
      type: Number,
      required: true,
      validator: function (v) { return v >= 1; }
    },
    boundaryLinks: {
      type: Boolean,
      default: false
    },
    directionLinks: {
      type: Boolean,
      default: true
    },
    size: String,
    align: String,
    totalPage: {
      type: Number,
      required: true,
      validator: function (v) { return v >= 0; }
    },
    maxSize: {
      type: Number,
      default: 5,
      validator: function (v) { return v >= 0; }
    },
    disabled: Boolean
  },
  data: function data () {
    return {
      sliceStart: 0
    }
  },
  computed: {
    navClasses: function navClasses () {
      var obj;

      return ( obj = {}, obj[("text-" + (this.align))] = Boolean(this.align), obj )
    },
    classes: function classes () {
      var obj;

      return ( obj = {}, obj[("pagination-" + (this.size))] = Boolean(this.size), obj )
    },
    sliceArray: function sliceArray () {
      return range(this.totalPage).slice(this.sliceStart, this.sliceStart + this.maxSize)
    }
  },
  methods: {
    calculateSliceStart: function calculateSliceStart () {
      var currentPage = this.value;
      var chunkSize = this.maxSize;
      var currentChunkStart = this.sliceStart;
      var currentChunkEnd = currentChunkStart + chunkSize;
      if (currentPage > currentChunkEnd) {
        var lastChunkStart = this.totalPage - chunkSize;
        if (currentPage > lastChunkStart) {
          this.sliceStart = lastChunkStart;
        } else {
          this.sliceStart = currentPage - 1;
        }
      } else if (currentPage < currentChunkStart + 1) {
        if (currentPage > chunkSize) {
          this.sliceStart = currentPage - chunkSize;
        } else {
          this.sliceStart = 0;
        }
      }
    },
    onPageChange: function onPageChange (page) {
      if (!this.disabled && page > 0 && page <= this.totalPage && page !== this.value) {
        this.$emit('input', page);
        this.$emit('change', page);
      }
    },
    toPage: function toPage (pre) {
      if (this.disabled) {
        return
      }
      var chunkSize = this.maxSize;
      var currentChunkStart = this.sliceStart;
      var lastChunkStart = this.totalPage - chunkSize;
      var start = pre ? currentChunkStart - chunkSize : currentChunkStart + chunkSize;
      if (start < 0) {
        this.sliceStart = 0;
      } else if (start > lastChunkStart) {
        this.sliceStart = lastChunkStart;
      } else {
        this.sliceStart = start;
      }
    }
  },
  created: function created () {
    this.$watch(function (vm) { return [vm.value, vm.maxSize, vm.totalPage].join(); }, this.calculateSliceStart, {
      immediate: true
    });
  }
};

/* script */
var __vue_script__$b = script$b;

/* template */
var __vue_render__$b = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "nav",
    { class: _vm.navClasses, attrs: { "aria-label": "Page navigation" } },
    [
      _c(
        "ul",
        { staticClass: "pagination", class: _vm.classes },
        [
          _vm.boundaryLinks
            ? _c(
                "li",
                { class: { disabled: _vm.value <= 1 || _vm.disabled } },
                [
                  _c(
                    "a",
                    {
                      attrs: {
                        href: "#",
                        role: "button",
                        "aria-label": "First"
                      },
                      on: {
                        click: function($event) {
                          $event.preventDefault();
                          return _vm.onPageChange(1)
                        }
                      }
                    },
                    [
                      _c("span", { attrs: { "aria-hidden": "true" } }, [
                        _vm._v("")
                      ])
                    ]
                  )
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.directionLinks
            ? _c(
                "li",
                { class: { disabled: _vm.value <= 1 || _vm.disabled } },
                [
                  _c(
                    "a",
                    {
                      attrs: {
                        href: "#",
                        role: "button",
                        "aria-label": "Previous"
                      },
                      on: {
                        click: function($event) {
                          $event.preventDefault();
                          return _vm.onPageChange(_vm.value - 1)
                        }
                      }
                    },
                    [
                      _c("span", { attrs: { "aria-hidden": "true" } }, [
                        _vm._v("")
                      ])
                    ]
                  )
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.sliceStart > 0
            ? _c("li", { class: { disabled: _vm.disabled } }, [
                _c(
                  "a",
                  {
                    attrs: {
                      href: "#",
                      role: "button",
                      "aria-label": "Previous group"
                    },
                    on: {
                      click: function($event) {
                        $event.preventDefault();
                        return _vm.toPage(1)
                      }
                    }
                  },
                  [
                    _c("span", { attrs: { "aria-hidden": "true" } }, [
                      _vm._v("")
                    ])
                  ]
                )
              ])
            : _vm._e(),
          _vm._v(" "),
          _vm._l(_vm.sliceArray, function(item) {
            return _c(
              "li",
              {
                key: item,
                class: {
                  active: _vm.value === item + 1,
                  disabled: _vm.disabled
                }
              },
              [
                _c(
                  "a",
                  {
                    attrs: { href: "#", role: "button" },
                    on: {
                      click: function($event) {
                        $event.preventDefault();
                        return _vm.onPageChange(item + 1)
                      }
                    }
                  },
                  [_vm._v(_vm._s(item + 1))]
                )
              ]
            )
          }),
          _vm._v(" "),
          _vm.sliceStart < _vm.totalPage - _vm.maxSize
            ? _c("li", { class: { disabled: _vm.disabled } }, [
                _c(
                  "a",
                  {
                    attrs: {
                      href: "#",
                      role: "button",
                      "aria-label": "Next group"
                    },
                    on: {
                      click: function($event) {
                        $event.preventDefault();
                        return _vm.toPage(0)
                      }
                    }
                  },
                  [
                    _c("span", { attrs: { "aria-hidden": "true" } }, [
                      _vm._v("")
                    ])
                  ]
                )
              ])
            : _vm._e(),
          _vm._v(" "),
          _vm.directionLinks
            ? _c(
                "li",
                {
                  class: {
                    disabled: _vm.value >= _vm.totalPage || _vm.disabled
                  }
                },
                [
                  _c(
                    "a",
                    {
                      attrs: {
                        href: "#",
                        role: "button",
                        "aria-label": "Next"
                      },
                      on: {
                        click: function($event) {
                          $event.preventDefault();
                          return _vm.onPageChange(_vm.value + 1)
                        }
                      }
                    },
                    [
                      _c("span", { attrs: { "aria-hidden": "true" } }, [
                        _vm._v("")
                      ])
                    ]
                  )
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.boundaryLinks
            ? _c(
                "li",
                {
                  class: {
                    disabled: _vm.value >= _vm.totalPage || _vm.disabled
                  }
                },
                [
                  _c(
                    "a",
                    {
                      attrs: {
                        href: "#",
                        role: "button",
                        "aria-label": "Last"
                      },
                      on: {
                        click: function($event) {
                          $event.preventDefault();
                          return _vm.onPageChange(_vm.totalPage)
                        }
                      }
                    },
                    [
                      _c("span", { attrs: { "aria-hidden": "true" } }, [
                        _vm._v("")
                      ])
                    ]
                  )
                ]
              )
            : _vm._e()
        ],
        2
      )
    ]
  )
};
var __vue_staticRenderFns__$b = [];
__vue_render__$b._withStripped = true;

  /* style */
  var __vue_inject_styles__$b = undefined;
  /* scoped */
  var __vue_scope_id__$b = undefined;
  /* module identifier */
  var __vue_module_identifier__$b = undefined;
  /* functional template */
  var __vue_is_functional_template__$b = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$b = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
    __vue_inject_styles__$b,
    __vue_script__$b,
    __vue_scope_id__$b,
    __vue_is_functional_template__$b,
    __vue_module_identifier__$b,
    false,
    undefined,
    undefined,
    undefined
  );

var SHOW_CLASS = 'in';

var popupMixin = {
  props: {
    value: {
      type: Boolean,
      default: false
    },
    tag: {
      type: String,
      default: 'span'
    },
    placement: {
      type: String,
      default: PLACEMENTS.TOP
    },
    autoPlacement: {
      type: Boolean,
      default: true
    },
    appendTo: {
      type: null,
      default: 'body'
    },
    transition: {
      type: Number,
      default: 150
    },
    hideDelay: {
      type: Number,
      default: 0
    },
    showDelay: {
      type: Number,
      default: 0
    },
    enable: {
      type: Boolean,
      default: true
    },
    enterable: {
      type: Boolean,
      default: true
    },
    target: null,
    viewport: null,
    customClass: String
  },
  data: function data () {
    return {
      triggerEl: null,
      hideTimeoutId: 0,
      showTimeoutId: 0,
      transitionTimeoutId: 0,
      autoTimeoutId: 0
    }
  },
  watch: {
    value: function value (v) {
      v ? this.show() : this.hide();
    },
    trigger: function trigger () {
      this.clearListeners();
      this.initListeners();
    },
    target: function target (value) {
      this.clearListeners();
      this.initTriggerElByTarget(value);
      this.initListeners();
    },
    allContent: function allContent (value) {
      var this$1 = this;

      // can not use value because it can not detect slot changes
      if (this.isNotEmpty()) {
        // reset position while content changed & is shown
        // nextTick is required
        this.$nextTick(function () {
          /* istanbul ignore else */
          if (this$1.isShown()) {
            this$1.resetPosition();
          }
        });
      } else {
        this.hide();
      }
    },
    enable: function enable (value) {
      // hide if enable changed to false
      /* istanbul ignore else */
      if (!value) {
        this.hide();
      }
    }
  },
  mounted: function mounted () {
    var this$1 = this;

    ensureElementMatchesFunction();
    removeFromDom(this.$refs.popup);
    this.$nextTick(function () {
      this$1.initTriggerElByTarget(this$1.target);
      this$1.initListeners();
      if (this$1.value) {
        this$1.show();
      }
    });
  },
  beforeDestroy: function beforeDestroy () {
    this.clearListeners();
    removeFromDom(this.$refs.popup);
  },
  methods: {
    initTriggerElByTarget: function initTriggerElByTarget (target) {
      if (target) {
        // target exist
        this.triggerEl = getElementBySelectorOrRef(target);
      } else {
        // find special element
        var trigger = this.$el.querySelector('[data-role="trigger"]');
        if (trigger) {
          this.triggerEl = trigger;
        } else {
          // use the first child
          var firstChild = this.$el.firstChild;
          this.triggerEl = firstChild === this.$refs.popup ? null : firstChild;
        }
      }
    },
    initListeners: function initListeners () {
      if (this.triggerEl) {
        if (this.trigger === TRIGGERS.HOVER) {
          on(this.triggerEl, EVENTS.MOUSE_ENTER, this.show);
          on(this.triggerEl, EVENTS.MOUSE_LEAVE, this.hide);
        } else if (this.trigger === TRIGGERS.FOCUS) {
          on(this.triggerEl, EVENTS.FOCUS, this.show);
          on(this.triggerEl, EVENTS.BLUR, this.hide);
        } else if (this.trigger === TRIGGERS.HOVER_FOCUS) {
          on(this.triggerEl, EVENTS.MOUSE_ENTER, this.handleAuto);
          on(this.triggerEl, EVENTS.MOUSE_LEAVE, this.handleAuto);
          on(this.triggerEl, EVENTS.FOCUS, this.handleAuto);
          on(this.triggerEl, EVENTS.BLUR, this.handleAuto);
        } else if (this.trigger === TRIGGERS.CLICK || this.trigger === TRIGGERS.OUTSIDE_CLICK) {
          on(this.triggerEl, EVENTS.CLICK, this.toggle);
        }
      }
      on(window, EVENTS.CLICK, this.windowClicked);
    },
    clearListeners: function clearListeners () {
      if (this.triggerEl) {
        off(this.triggerEl, EVENTS.FOCUS, this.show);
        off(this.triggerEl, EVENTS.BLUR, this.hide);
        off(this.triggerEl, EVENTS.MOUSE_ENTER, this.show);
        off(this.triggerEl, EVENTS.MOUSE_LEAVE, this.hide);
        off(this.triggerEl, EVENTS.CLICK, this.toggle);
        off(this.triggerEl, EVENTS.MOUSE_ENTER, this.handleAuto);
        off(this.triggerEl, EVENTS.MOUSE_LEAVE, this.handleAuto);
        off(this.triggerEl, EVENTS.FOCUS, this.handleAuto);
        off(this.triggerEl, EVENTS.BLUR, this.handleAuto);
      }
      off(window, EVENTS.CLICK, this.windowClicked);
      this.clearTimeouts();
    },
    clearTimeouts: function clearTimeouts () {
      if (this.hideTimeoutId) {
        clearTimeout(this.hideTimeoutId);
        this.hideTimeoutId = 0;
      }
      if (this.showTimeoutId) {
        clearTimeout(this.showTimeoutId);
        this.showTimeoutId = 0;
      }
      if (this.transitionTimeoutId) {
        clearTimeout(this.transitionTimeoutId);
        this.transitionTimeoutId = 0;
      }
      if (this.autoTimeoutId) {
        clearTimeout(this.autoTimeoutId);
        this.autoTimeoutId = 0;
      }
    },
    resetPosition: function resetPosition () {
      var popup = this.$refs.popup;
      /* istanbul ignore else */
      if (popup) {
        setTooltipPosition(popup, this.triggerEl, this.placement, this.autoPlacement, this.appendTo, this.viewport);
        popup.offsetHeight;
      }
    },
    hideOnLeave: function hideOnLeave () {
      if (this.trigger === TRIGGERS.HOVER || (this.trigger === TRIGGERS.HOVER_FOCUS && !this.triggerEl.matches(':focus'))) {
        this.$hide();
      }
    },
    toggle: function toggle () {
      if (this.isShown()) {
        this.hide();
      } else {
        this.show();
      }
    },
    show: function show () {
      var this$1 = this;

      if (this.enable && this.triggerEl && this.isNotEmpty() && !this.isShown()) {
        var popUpAppendedContainer = this.hideTimeoutId > 0; // weird condition
        if (popUpAppendedContainer) {
          clearTimeout(this.hideTimeoutId);
          this.hideTimeoutId = 0;
        }
        if (this.transitionTimeoutId > 0) {
          clearTimeout(this.transitionTimeoutId);
          this.transitionTimeoutId = 0;
        }
        clearTimeout(this.showTimeoutId);
        this.showTimeoutId = setTimeout(function () {
          this$1.showTimeoutId = 0;
          var popup = this$1.$refs.popup;
          if (popup) {
            var alreadyOpenModalNum = getOpenModalNum();
            if (alreadyOpenModalNum > 1) {
              var defaultZ = this$1.name === 'popover' ? 1060 : 1070;
              var offset = (alreadyOpenModalNum - 1) * 20;
              popup.style.zIndex = "" + (defaultZ + offset);
            }
            // add to dom
            if (!popUpAppendedContainer) {
              popup.className = (this$1.name) + " " + (this$1.placement) + " " + (this$1.customClass ? this$1.customClass : '') + " fade";
              var container = getElementBySelectorOrRef(this$1.appendTo);
              container.appendChild(popup);
              this$1.resetPosition();
            }
            addClass(popup, SHOW_CLASS);
            this$1.$emit('input', true);
            this$1.$emit('show');
          }
        }, this.showDelay);
      }
    },
    hide: function hide () {
      var this$1 = this;

      if (this.showTimeoutId > 0) {
        clearTimeout(this.showTimeoutId);
        this.showTimeoutId = 0;
      }

      if (!this.isShown()) {
        return
      }
      if (this.enterable && (this.trigger === TRIGGERS.HOVER || this.trigger === TRIGGERS.HOVER_FOCUS)) {
        clearTimeout(this.hideTimeoutId);
        this.hideTimeoutId = setTimeout(function () {
          this$1.hideTimeoutId = 0;
          var popup = this$1.$refs.popup;
          if (popup && !popup.matches(':hover')) {
            this$1.$hide();
          }
        }, 100);
      } else {
        this.$hide();
      }
    },
    $hide: function $hide () {
      var this$1 = this;

      if (this.isShown()) {
        clearTimeout(this.hideTimeoutId);
        this.hideTimeoutId = setTimeout(function () {
          this$1.hideTimeoutId = 0;
          removeClass(this$1.$refs.popup, SHOW_CLASS);
          // gives fade out time
          this$1.transitionTimeoutId = setTimeout(function () {
            this$1.transitionTimeoutId = 0;
            removeFromDom(this$1.$refs.popup);
            this$1.$emit('input', false);
            this$1.$emit('hide');
          }, this$1.transition);
        }, this.hideDelay);
      }
    },
    isShown: function isShown () {
      return hasClass(this.$refs.popup, SHOW_CLASS)
    },
    windowClicked: function windowClicked (event) {
      if (this.triggerEl && isFunction(this.triggerEl.contains) && !this.triggerEl.contains(event.target) &&
        this.trigger === TRIGGERS.OUTSIDE_CLICK && !(this.$refs.popup && this.$refs.popup.contains(event.target)) &&
        this.isShown()) {
        this.hide();
      }
    },
    handleAuto: function handleAuto () {
      var this$1 = this;

      clearTimeout(this.autoTimeoutId);
      this.autoTimeoutId = setTimeout(function () {
        this$1.autoTimeoutId = 0;
        if (this$1.triggerEl.matches(':hover, :focus')) {
          this$1.show();
        } else {
          this$1.hide();
        }
      }, 20); // 20ms make firefox happy
    }
  }
};

var Tooltip = {
  mixins: [popupMixin],
  data: function data () {
    return {
      name: 'tooltip'
    }
  },
  render: function render (h) {
    return h(
      this.tag,
      [
        this.$slots.default,
        h('div',
          {
            ref: 'popup',
            attrs: {
              role: 'tooltip'
            },
            on: {
              mouseleave: this.hideOnLeave
            }
          },
          [
            h('div', { class: 'tooltip-arrow' }),
            h('div', {
              class: 'tooltip-inner',
              domProps: { innerHTML: this.text }
            })
          ]
        )
      ]
    )
  },
  props: {
    text: {
      type: String,
      default: ''
    },
    trigger: {
      type: String,
      default: TRIGGERS.HOVER_FOCUS
    }
  },
  computed: {
    allContent: function allContent () {
      return this.text
    }
  },
  methods: {
    isNotEmpty: function isNotEmpty () {
      return this.text
    }
  }
};

var Popover = {
  mixins: [popupMixin],
  data: function data () {
    return {
      name: 'popover'
    }
  },
  render: function render (h) {
    return h(this.tag,
      [
        this.$slots.default,
        h('div',
          {
            style: {
              display: 'block'
            },
            ref: 'popup',
            on: {
              mouseleave: this.hideOnLeave
            }
          },
          [
            h('div', { class: 'arrow' }),
            h('h3', {
              class: 'popover-title',
              directives: [
                { name: 'show', value: this.title }
              ]
            }, this.title),
            h('div', { class: 'popover-content' }, [this.content || this.$slots.popover])
          ]
        )
      ]
    )
  },
  props: {
    title: {
      type: String,
      default: ''
    },
    content: {
      type: String,
      default: ''
    },
    trigger: {
      type: String,
      default: TRIGGERS.OUTSIDE_CLICK
    }
  },
  computed: {
    allContent: function allContent () {
      return this.title + this.content
    }
  },
  methods: {
    isNotEmpty: function isNotEmpty () {
      return this.title || this.content || this.$slots.popover
    }
  }
};

var maxHours = 23;
var zero = 0;
var maxMinutes = 59;
var cutUpAmAndPm = 12;

var script$c = {
  components: { Btn: Btn },
  mixins: [Local],
  props: {
    value: {
      type: Date,
      required: true
    },
    showMeridian: {
      type: Boolean,
      default: true
    },
    min: Date,
    max: Date,
    hourStep: {
      type: Number,
      default: 1
    },
    minStep: {
      type: Number,
      default: 1
    },
    readonly: {
      type: Boolean,
      default: false
    },
    controls: {
      type: Boolean,
      default: true
    },
    iconControlUp: {
      type: String,
      default: 'glyphicon glyphicon-chevron-up'
    },
    iconControlDown: {
      type: String,
      default: 'glyphicon glyphicon-chevron-down'
    },
    inputWidth: {
      type: Number,
      default: 50
    }
  },
  data: function data () {
    return {
      hours: 0,
      minutes: 0,
      meridian: true,
      hoursText: '',
      minutesText: ''
    }
  },
  mounted: function mounted () {
    this.updateByValue(this.value);
  },
  computed: {
    inputStyles: function inputStyles () {
      return {
        width: ((this.inputWidth) + "px")
      }
    }
  },
  watch: {
    value: function value (value$1) {
      this.updateByValue(value$1);
    },
    showMeridian: function showMeridian (value) {
      this.setTime();
    },
    hoursText: function hoursText (value) {
      if (this.hours === 0 && value === '') {
        // Prevent a runtime reset from being overwritten
        return
      }
      var hour = parseInt(value);
      if (this.showMeridian) {
        if (hour >= 1 && hour <= cutUpAmAndPm) {
          if (this.meridian) {
            this.hours = hour === cutUpAmAndPm ? 0 : hour;
          } else {
            this.hours = hour === cutUpAmAndPm ? cutUpAmAndPm : hour + cutUpAmAndPm;
          }
        }
      } else if (hour >= zero && hour <= maxHours) {
        this.hours = hour;
      }
      this.setTime();
    },
    minutesText: function minutesText (value) {
      if (this.minutes === 0 && value === '') {
        // Prevent a runtime reset from being overwritten
        return
      }
      var minutesStr = parseInt(value);
      if (minutesStr >= zero && minutesStr <= maxMinutes) {
        this.minutes = minutesStr;
      }
      this.setTime();
    }
  },
  methods: {
    updateByValue: function updateByValue (value) {
      if (isNaN(value.getTime())) {
        this.hours = 0;
        this.minutes = 0;
        this.hoursText = '';
        this.minutesText = '';
        this.meridian = true;
        return
      }
      this.hours = value.getHours();
      this.minutes = value.getMinutes();
      if (!this.showMeridian) {
        this.hoursText = pad(this.hours, 2);
      } else {
        if (this.hours >= cutUpAmAndPm) {
          if (this.hours === cutUpAmAndPm) {
            this.hoursText = this.hours + '';
          } else {
            this.hoursText = pad(this.hours - cutUpAmAndPm, 2);
          }
          this.meridian = false;
        } else {
          if (this.hours === zero) {
            this.hoursText = cutUpAmAndPm.toString();
          } else {
            this.hoursText = pad(this.hours, 2);
          }
          this.meridian = true;
        }
      }
      this.minutesText = pad(this.minutes, 2);
      // lazy model won't update when using keyboard up/down
      this.$refs.hoursInput.value = this.hoursText;
      this.$refs.minutesInput.value = this.minutesText;
    },
    addHour: function addHour (step) {
      step = step || this.hourStep;
      this.hours = this.hours >= maxHours ? zero : this.hours + step;
    },
    reduceHour: function reduceHour (step) {
      step = step || this.hourStep;
      this.hours = this.hours <= zero ? maxHours : this.hours - step;
    },
    addMinute: function addMinute () {
      if (this.minutes >= maxMinutes) {
        this.minutes = zero;
        this.addHour(1);
      } else {
        this.minutes += this.minStep;
      }
    },
    reduceMinute: function reduceMinute () {
      if (this.minutes <= zero) {
        this.minutes = maxMinutes + 1 - this.minStep;
        this.reduceHour(1);
      } else {
        this.minutes -= this.minStep;
      }
    },
    changeTime: function changeTime (isHour, isPlus) {
      if (!this.readonly) {
        if (isHour && isPlus) {
          this.addHour();
        } else if (isHour && !isPlus) {
          this.reduceHour();
        } else if (!isHour && isPlus) {
          this.addMinute();
        } else {
          this.reduceMinute();
        }
        this.setTime();
      }
    },
    toggleMeridian: function toggleMeridian () {
      this.meridian = !this.meridian;
      if (this.meridian) {
        this.hours -= cutUpAmAndPm;
      } else {
        this.hours += cutUpAmAndPm;
      }
      this.setTime();
    },
    onWheel: function onWheel (e, isHour) {
      if (!this.readonly) {
        e.preventDefault();
        this.changeTime(isHour, e.deltaY < 0);
      }
    },
    setTime: function setTime () {
      var time = this.value;
      if (isNaN(time.getTime())) {
        time = new Date();
        time.setHours(0);
        time.setMinutes(0);
      }
      time.setHours(this.hours);
      time.setMinutes(this.minutes);
      if (this.max) {
        var max = new Date(time);
        max.setHours(this.max.getHours());
        max.setMinutes(this.max.getMinutes());
        time = time > max ? max : time;
      }
      if (this.min) {
        var min = new Date(time);
        min.setHours(this.min.getHours());
        min.setMinutes(this.min.getMinutes());
        time = time < min ? min : time;
      }
      this.$emit('input', new Date(time));
    },
    selectInputValue: function selectInputValue (e) {
      // mouseup should be prevented!
      // See various comments in https://stackoverflow.com/questions/3272089/programmatically-selecting-text-in-an-input-field-on-ios-devices-mobile-safari
      e.target.setSelectionRange(0, 2);
    }
  }
};

/* script */
var __vue_script__$c = script$c;

/* template */
var __vue_render__$c = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "section",
    {
      on: {
        click: function($event) {
          $event.stopPropagation();
        }
      }
    },
    [
      _c("table", [
        _c("tbody", [
          _vm.controls
            ? _c("tr", { staticClass: "text-center" }, [
                _c(
                  "td",
                  [
                    _c(
                      "btn",
                      {
                        attrs: {
                          type: "link",
                          size: "sm",
                          disabled: _vm.readonly
                        },
                        on: {
                          click: function($event) {
                            return _vm.changeTime(1, 1)
                          }
                        }
                      },
                      [_c("i", { class: _vm.iconControlUp })]
                    )
                  ],
                  1
                ),
                _vm._v(" "),
                _c("td", [_vm._v("")]),
                _vm._v(" "),
                _c(
                  "td",
                  [
                    _c(
                      "btn",
                      {
                        attrs: {
                          type: "link",
                          size: "sm",
                          disabled: _vm.readonly
                        },
                        on: {
                          click: function($event) {
                            return _vm.changeTime(0, 1)
                          }
                        }
                      },
                      [_c("i", { class: _vm.iconControlUp })]
                    )
                  ],
                  1
                ),
                _vm._v(" "),
                _vm.showMeridian ? _c("td") : _vm._e()
              ])
            : _vm._e(),
          _vm._v(" "),
          _c("tr", [
            _c("td", { staticClass: "form-group" }, [
              _c("input", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model.lazy",
                    value: _vm.hoursText,
                    expression: "hoursText",
                    modifiers: { lazy: true }
                  }
                ],
                ref: "hoursInput",
                staticClass: "form-control text-center",
                style: _vm.inputStyles,
                attrs: {
                  type: "tel",
                  pattern: "\\d*",
                  placeholder: "HH",
                  readonly: _vm.readonly,
                  maxlength: "2",
                  size: "2"
                },
                domProps: { value: _vm.hoursText },
                on: {
                  mouseup: _vm.selectInputValue,
                  keydown: [
                    function($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "up", 38, $event.key, [
                          "Up",
                          "ArrowUp"
                        ])
                      ) {
                        return null
                      }
                      $event.preventDefault();
                      return _vm.changeTime(1, 1)
                    },
                    function($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "down", 40, $event.key, [
                          "Down",
                          "ArrowDown"
                        ])
                      ) {
                        return null
                      }
                      $event.preventDefault();
                      return _vm.changeTime(1, 0)
                    }
                  ],
                  wheel: function($event) {
                    return _vm.onWheel($event, true)
                  },
                  change: function($event) {
                    _vm.hoursText = $event.target.value;
                  }
                }
              })
            ]),
            _vm._v(" "),
            _vm._m(0),
            _vm._v(" "),
            _c("td", { staticClass: "form-group" }, [
              _c("input", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model.lazy",
                    value: _vm.minutesText,
                    expression: "minutesText",
                    modifiers: { lazy: true }
                  }
                ],
                ref: "minutesInput",
                staticClass: "form-control text-center",
                style: _vm.inputStyles,
                attrs: {
                  type: "tel",
                  pattern: "\\d*",
                  placeholder: "MM",
                  readonly: _vm.readonly,
                  maxlength: "2",
                  size: "2"
                },
                domProps: { value: _vm.minutesText },
                on: {
                  mouseup: _vm.selectInputValue,
                  keydown: [
                    function($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "up", 38, $event.key, [
                          "Up",
                          "ArrowUp"
                        ])
                      ) {
                        return null
                      }
                      $event.preventDefault();
                      return _vm.changeTime(0, 1)
                    },
                    function($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "down", 40, $event.key, [
                          "Down",
                          "ArrowDown"
                        ])
                      ) {
                        return null
                      }
                      $event.preventDefault();
                      return _vm.changeTime(0, 0)
                    }
                  ],
                  wheel: function($event) {
                    return _vm.onWheel($event, false)
                  },
                  change: function($event) {
                    _vm.minutesText = $event.target.value;
                  }
                }
              })
            ]),
            _vm._v(" "),
            _vm.showMeridian
              ? _c(
                  "td",
                  [
                    _vm._v("\n        \n        "),
                    _c("btn", {
                      attrs: {
                        "data-action": "toggleMeridian",
                        disabled: _vm.readonly
                      },
                      domProps: {
                        textContent: _vm._s(
                          _vm.meridian
                            ? _vm.t("uiv.timePicker.am")
                            : _vm.t("uiv.timePicker.pm")
                        )
                      },
                      on: { click: _vm.toggleMeridian }
                    })
                  ],
                  1
                )
              : _vm._e()
          ]),
          _vm._v(" "),
          _vm.controls
            ? _c("tr", { staticClass: "text-center" }, [
                _c(
                  "td",
                  [
                    _c(
                      "btn",
                      {
                        attrs: {
                          type: "link",
                          size: "sm",
                          disabled: _vm.readonly
                        },
                        on: {
                          click: function($event) {
                            return _vm.changeTime(1, 0)
                          }
                        }
                      },
                      [_c("i", { class: _vm.iconControlDown })]
                    )
                  ],
                  1
                ),
                _vm._v(" "),
                _c("td", [_vm._v("")]),
                _vm._v(" "),
                _c(
                  "td",
                  [
                    _c(
                      "btn",
                      {
                        attrs: {
                          type: "link",
                          size: "sm",
                          disabled: _vm.readonly
                        },
                        on: {
                          click: function($event) {
                            return _vm.changeTime(0, 0)
                          }
                        }
                      },
                      [_c("i", { class: _vm.iconControlDown })]
                    )
                  ],
                  1
                ),
                _vm._v(" "),
                _vm.showMeridian ? _c("td") : _vm._e()
              ])
            : _vm._e()
        ])
      ])
    ]
  )
};
var __vue_staticRenderFns__$c = [
  function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("td", [_vm._v(""), _c("b", [_vm._v(":")]), _vm._v("")])
  }
];
__vue_render__$c._withStripped = true;

  /* style */
  var __vue_inject_styles__$c = undefined;
  /* scoped */
  var __vue_scope_id__$c = undefined;
  /* module identifier */
  var __vue_module_identifier__$c = undefined;
  /* functional template */
  var __vue_is_functional_template__$c = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$c = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
    __vue_inject_styles__$c,
    __vue_script__$c,
    __vue_scope_id__$c,
    __vue_is_functional_template__$c,
    __vue_module_identifier__$c,
    false,
    undefined,
    undefined,
    undefined
  );

function request (url, method) {
  if ( method === void 0 ) method = 'GET';

  var request = new window.XMLHttpRequest();
  var data = {};
  var p = {
    then: function (fn1, fn2) { return p.done(fn1).fail(fn2); },
    catch: function (fn) { return p.fail(fn); },
    always: function (fn) { return p.done(fn).fail(fn); }
  };
  var statuses = ['done', 'fail'];
  statuses.forEach(function (name) {
    data[name] = [];
    p[name] = function (fn) {
      if (fn instanceof Function) { data[name].push(fn); }
      return p
    };
  });
  p.done(JSON.parse);
  request.onreadystatechange = function () {
    if (request.readyState === 4) {
      var e = { status: request.status };
      if (request.status === 200) {
        var response = request.responseText;
        for (var i in data.done) {
          /* istanbul ignore else */
          if (hasOwnProperty(data.done, i) && isFunction(data.done[i])) {
            var value = data.done[i](response);
            if (isExist(value)) {
              response = value;
            }
          }
        }
      } else {
        data.fail.forEach(function (fail) { return fail(e); });
      }
    }
  };
  request.open(method, url);
  request.setRequestHeader('Accept', 'application/json');
  request.send();
  return p
}

var script$d = {
  components: { Dropdown: Dropdown },
  props: {
    value: {
      required: true
    },
    data: Array,
    itemKey: String,
    appendToBody: {
      type: Boolean,
      default: false
    },
    ignoreCase: {
      type: Boolean,
      default: true
    },
    matchStart: {
      type: Boolean,
      default: false
    },
    forceSelect: {
      type: Boolean,
      default: false
    },
    forceClear: {
      type: Boolean,
      default: false
    },
    limit: {
      type: Number,
      default: 10
    },
    asyncSrc: String,
    asyncKey: String,
    asyncFunction: Function,
    debounce: {
      type: Number,
      default: 200
    },
    openOnFocus: {
      type: Boolean,
      default: true
    },
    openOnEmpty: {
      type: Boolean,
      default: false
    },
    target: {
      required: true
    },
    preselect: {
      type: Boolean,
      default: true
    }
  },
  data: function data () {
    return {
      inputEl: null,
      items: [],
      activeIndex: 0,
      timeoutID: 0,
      elements: [],
      open: false,
      dropdownMenuEl: null
    }
  },
  computed: {
    regexOptions: function regexOptions () {
      var options = '';
      if (this.ignoreCase) {
        options += 'i';
      }
      if (!this.matchStart) {
        options += 'g';
      }
      return options
    }
  },
  mounted: function mounted () {
    var this$1 = this;

    ensureElementMatchesFunction();
    this.$nextTick(function () {
      this$1.initInputElByTarget(this$1.target);
      this$1.initListeners();
      this$1.dropdownMenuEl = this$1.$refs.dropdown.$el.querySelector('.dropdown-menu');
      // set input text if v-model not empty
      if (this$1.value) {
        this$1.setInputTextByValue(this$1.value);
      }
    });
  },
  beforeDestroy: function beforeDestroy () {
    this.removeListeners();
  },
  watch: {
    target: function target (el) {
      this.removeListeners();
      this.initInputElByTarget(el);
      this.initListeners();
    },
    value: function value (value$1) {
      this.setInputTextByValue(value$1);
    }
  },
  methods: {
    setInputTextByValue: function setInputTextByValue (value) {
      if (isString(value)) {
        // direct
        this.inputEl.value = value;
      } else if (value) {
        // is object
        this.inputEl.value = this.itemKey ? value[this.itemKey] : value;
      } else if (value === null) {
        // is null or undefined or something else not valid
        this.inputEl.value = '';
      }
    },
    hasEmptySlot: function hasEmptySlot () {
      return !!this.$slots.empty || !!this.$scopedSlots.empty
    },
    initInputElByTarget: function initInputElByTarget (target) {
      if (!target) {
        return
      }
      this.inputEl = getElementBySelectorOrRef(target);
    },
    initListeners: function initListeners () {
      if (this.inputEl) {
        this.elements = [this.inputEl];
        on(this.inputEl, EVENTS.FOCUS, this.inputFocused);
        on(this.inputEl, EVENTS.BLUR, this.inputBlured);
        on(this.inputEl, EVENTS.INPUT, this.inputChanged);
        on(this.inputEl, EVENTS.KEY_DOWN, this.inputKeyPressed);
      }
    },
    removeListeners: function removeListeners () {
      this.elements = [];
      if (this.inputEl) {
        off(this.inputEl, EVENTS.FOCUS, this.inputFocused);
        off(this.inputEl, EVENTS.BLUR, this.inputBlured);
        off(this.inputEl, EVENTS.INPUT, this.inputChanged);
        off(this.inputEl, EVENTS.KEY_DOWN, this.inputKeyPressed);
      }
    },
    prepareItems: function prepareItems (data, disableFilters) {
      if ( disableFilters === void 0 ) disableFilters = false;

      if (disableFilters) {
        this.items = data.slice(0, this.limit);
        return
      }
      this.items = [];
      this.activeIndex = this.preselect ? 0 : -1;
      for (var i = 0, l = data.length; i < l; i++) {
        var item = data[i];
        var key = this.itemKey ? item[this.itemKey] : item;
        key = key.toString();
        var index = -1;
        if (this.ignoreCase) {
          index = key.toLowerCase().indexOf(this.inputEl.value.toLowerCase());
        } else {
          index = key.indexOf(this.inputEl.value);
        }
        if (this.matchStart ? index === 0 : index >= 0) {
          this.items.push(item);
        }
        if (this.items.length >= this.limit) {
          break
        }
      }
    },
    fetchItems: function fetchItems (value, debounce) {
      var this$1 = this;

      clearTimeout(this.timeoutID);
      if (value === '' && !this.openOnEmpty) {
        this.open = false;
      } else if (this.data) {
        this.prepareItems(this.data);
        this.open = this.hasEmptySlot() || Boolean(this.items.length);
      } else if (this.asyncSrc) {
        this.timeoutID = setTimeout(function () {
          this$1.$emit('loading');
          request(this$1.asyncSrc + encodeURIComponent(value))
            .then(function (data) {
              if (this$1.inputEl.matches(':focus')) {
                this$1.prepareItems(this$1.asyncKey ? data[this$1.asyncKey] : data, true);
                this$1.open = this$1.hasEmptySlot() || Boolean(this$1.items.length);
              }
              this$1.$emit('loaded');
            })
            .catch(function (err) {
              console.error(err);
              this$1.$emit('loaded-error');
            });
        }, debounce);
      } else if (this.asyncFunction) {
        var cb = function (data) {
          if (this$1.inputEl.matches(':focus')) {
            this$1.prepareItems(data, true);
            this$1.open = this$1.hasEmptySlot() || Boolean(this$1.items.length);
          }
          this$1.$emit('loaded');
        };
        this.timeoutID = setTimeout(function () {
          this$1.$emit('loading');
          this$1.asyncFunction(value, cb);
        }, debounce);
      }
    },
    inputChanged: function inputChanged () {
      var value = this.inputEl.value;
      this.fetchItems(value, this.debounce);
      this.$emit('input', this.forceSelect ? undefined : value);
    },
    inputFocused: function inputFocused () {
      if (this.openOnFocus) {
        var value = this.inputEl.value;
        this.fetchItems(value, 0);
      }
    },
    inputBlured: function inputBlured () {
      var this$1 = this;

      if (!this.dropdownMenuEl.matches(':hover')) {
        this.open = false;
      }
      if (this.inputEl && this.forceClear) {
        this.$nextTick(function () {
          if (typeof this$1.value === 'undefined') {
            this$1.inputEl.value = '';
          }
        });
      }
    },
    inputKeyPressed: function inputKeyPressed (event) {
      event.stopPropagation();
      if (this.open) {
        switch (event.keyCode) {
          case 13:
            if (this.activeIndex >= 0) {
              this.selectItem(this.items[this.activeIndex]);
            } else {
              this.open = false;
            }
            event.preventDefault();
            break
          case 27:
            this.open = false;
            break
          case 38:
            this.activeIndex = this.activeIndex > 0 ? this.activeIndex - 1 : 0;
            break
          case 40: {
            var maxIndex = this.items.length - 1;
            this.activeIndex = this.activeIndex < maxIndex ? this.activeIndex + 1 : maxIndex;
            break
          }
        }
      }
    },
    selectItem: function selectItem (item) {
      this.$emit('input', item);
      this.open = false;
    },
    highlight: function highlight (item) {
      var value = this.itemKey ? item[this.itemKey] : item;
      var inputValue = this.inputEl.value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
      return value.replace(new RegExp(("" + inputValue), this.regexOptions), '<b>$&</b>')
    }
  }
};

/* script */
var __vue_script__$d = script$d;

/* template */
var __vue_render__$d = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "dropdown",
    {
      ref: "dropdown",
      attrs: {
        tag: "section",
        "append-to-body": _vm.appendToBody,
        "not-close-elements": _vm.elements,
        "position-element": _vm.inputEl
      },
      model: {
        value: _vm.open,
        callback: function($$v) {
          _vm.open = $$v;
        },
        expression: "open"
      }
    },
    [
      _c(
        "template",
        { slot: "dropdown" },
        [
          _vm._t(
            "item",
            _vm._l(_vm.items, function(item, index) {
              return _c(
                "li",
                { class: { active: _vm.activeIndex === index } },
                [
                  _c(
                    "a",
                    {
                      attrs: { href: "#" },
                      on: {
                        click: function($event) {
                          $event.preventDefault();
                          return _vm.selectItem(item)
                        }
                      }
                    },
                    [
                      _c("span", {
                        domProps: { innerHTML: _vm._s(_vm.highlight(item)) }
                      })
                    ]
                  )
                ]
              )
            }),
            {
              items: _vm.items,
              activeIndex: _vm.activeIndex,
              select: _vm.selectItem,
              highlight: _vm.highlight
            }
          ),
          _vm._v(" "),
          !_vm.items || _vm.items.length === 0 ? _vm._t("empty") : _vm._e()
        ],
        2
      )
    ],
    2
  )
};
var __vue_staticRenderFns__$d = [];
__vue_render__$d._withStripped = true;

  /* style */
  var __vue_inject_styles__$d = undefined;
  /* scoped */
  var __vue_scope_id__$d = undefined;
  /* module identifier */
  var __vue_module_identifier__$d = undefined;
  /* functional template */
  var __vue_is_functional_template__$d = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$d = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
    __vue_inject_styles__$d,
    __vue_script__$d,
    __vue_scope_id__$d,
    __vue_is_functional_template__$d,
    __vue_module_identifier__$d,
    false,
    undefined,
    undefined,
    undefined
  );

var ProgressBarStack = {
  functional: true,
  render: function render (h, ref) {
    var obj;

    var props = ref.props;
    var data = ref.data;
    return h(
      'div',
      a(data, {
        class: ( obj = {
          'progress-bar': true,
          'progress-bar-striped': props.striped,
          active: props.striped && props.active
        }, obj[("progress-bar-" + (props.type))] = Boolean(props.type), obj ),
        style: {
          minWidth: props.minWidth ? '2em' : null,
          width: ((props.value) + "%")
        },
        attrs: {
          role: 'progressbar',
          'aria-valuemin': 0,
          'aria-valuenow': props.value,
          'aria-valuemax': 100
        }
      }),
      props.label ? (props.labelText ? props.labelText : ((props.value) + "%")) : null
    )
  },
  props: {
    value: {
      type: Number,
      required: true,
      validator: function validator (value) {
        return value >= 0 && value <= 100
      }
    },
    labelText: String,
    type: String,
    label: {
      type: Boolean,
      default: false
    },
    minWidth: {
      type: Boolean,
      default: false
    },
    striped: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: false
    }
  }
};

var ProgressBar = {
  functional: true,
  render: function render (h, ref) {
    var props = ref.props;
    var data = ref.data;
    var children = ref.children;

    return h(
      'div',
      a(data, { class: 'progress' }),
      children && children.length ? children : [h(ProgressBarStack, { props: props })]
    )
  }
};

var BreadcrumbItem = {
  functional: true,
  mixins: [linkMixin],
  render: function render (h, ref) {
    var props = ref.props;
    var data = ref.data;
    var children = ref.children;

    var slot;
    if (props.active) {
      slot = children;
    } else if (props.to) {
      slot = [
        h('router-link', {
          props: {
            to: props.to,
            replace: props.replace,
            append: props.append,
            exact: props.exact
          }
        }, children)
      ];
    } else {
      slot = [
        h('a', {
          attrs: {
            href: props.href,
            target: props.target
          }
        }, children)
      ];
    }
    return h('li', a(data, { class: { active: props.active } }), slot)
  },
  props: {
    active: {
      type: Boolean,
      default: false
    }
  }
};

var Breadcrumbs = {
  functional: true,
  render: function render (h, ref) {
    var props = ref.props;
    var data = ref.data;
    var children = ref.children;

    var slot = [];
    if (children && children.length) {
      slot = children;
    } else if (props.items) {
      slot = props.items.map(function (item, index) {
        return h(
          BreadcrumbItem,
          {
            key: hasOwnProperty(item, 'key') ? item.key : index,
            props: {
              active: hasOwnProperty(item, 'active') ? item.active : index === props.items.length - 1,
              href: item.href,
              target: item.target,
              to: item.to,
              replace: item.replace,
              append: item.append,
              exact: item.exact
            }
          },
          item.text
        )
      });
    }
    return h('ol', a(data, { class: 'breadcrumb' }), slot)
  },
  props: {
    items: Array
  }
};

var BtnToolbar = {
  functional: true,
  render: function render (h, ref) {
    var children = ref.children;
    var data = ref.data;

    return h(
      'div',
      a(data, {
        class: {
          'btn-toolbar': true
        },
        attrs: {
          role: 'toolbar'
        }
      }),
      children
    )
  }
};

var script$e = {
  mixins: [Local],
  components: { Dropdown: Dropdown },
  props: {
    value: {
      type: Array,
      required: true
    },
    options: {
      type: Array,
      required: true
    },
    labelKey: {
      type: String,
      default: 'label'
    },
    valueKey: {
      type: String,
      default: 'value'
    },
    limit: {
      type: Number,
      default: 0
    },
    size: String,
    placeholder: String,
    split: {
      type: String,
      default: ', '
    },
    disabled: {
      type: Boolean,
      default: false
    },
    appendToBody: {
      type: Boolean,
      default: false
    },
    block: {
      type: Boolean,
      default: false
    },
    collapseSelected: {
      type: Boolean,
      default: false
    },
    filterable: {
      type: Boolean,
      default: false
    },
    filterAutoFocus: {
      type: Boolean,
      default: true
    },
    filterFunction: Function,
    filterPlaceholder: String,
    selectedIcon: {
      type: String,
      default: 'glyphicon glyphicon-ok'
    },
    itemSelectedClass: String
  },
  data: function data () {
    return {
      showDropdown: false,
      els: [],
      filterInput: '',
      currentActive: -1
    }
  },
  computed: {
    containerStyles: function containerStyles () {
      return {
        width: this.block ? '100%' : ''
      }
    },
    filteredOptions: function filteredOptions () {
      var this$1 = this;

      if (this.filterable && this.filterInput) {
        if (this.filterFunction) {
          return this.filterFunction(this.filterInput)
        } else {
          var filterInput = this.filterInput.toLowerCase();
          return this.options.filter(function (v) { return (
            v[this$1.valueKey].toString().toLowerCase().indexOf(filterInput) >= 0 ||
            v[this$1.labelKey].toString().toLowerCase().indexOf(filterInput) >= 0
          ); })
        }
      } else {
        return this.options
      }
    },
    groupedOptions: function groupedOptions () {
      var this$1 = this;

      return this.filteredOptions
        .map(function (v) { return v.group; })
        .filter(onlyUnique)
        .map(function (v) { return ({
          options: this$1.filteredOptions.filter(function (option) { return option.group === v; }),
          $group: v
        }); })
    },
    flattenGroupedOptions: function flattenGroupedOptions () {
      var ref;

      return (ref = []).concat.apply(ref, this.groupedOptions.map(function (v) { return v.options; }))
    },
    selectClasses: function selectClasses () {
      var obj;

      return ( obj = {}, obj[("input-" + (this.size))] = this.size, obj )
    },
    selectedIconClasses: function selectedIconClasses () {
      var obj;

      return ( obj = {}, obj[this.selectedIcon] = true, obj['pull-right'] = true, obj )
    },
    selectTextClasses: function selectTextClasses () {
      return {
        'text-muted': this.value.length === 0
      }
    },
    labelValue: function labelValue () {
      var this$1 = this;

      var optionsByValue = this.options.map(function (v) { return v[this$1.valueKey]; });
      return this.value.map(function (v) {
        var index = optionsByValue.indexOf(v);
        return index >= 0 ? this$1.options[index][this$1.labelKey] : v
      })
    },
    selectedText: function selectedText () {
      if (this.value.length) {
        var labelValue = this.labelValue;
        if (this.collapseSelected) {
          var str = labelValue[0];
          str += labelValue.length > 1 ? ((this.split) + "+" + (labelValue.length - 1)) : '';
          return str
        } else {
          return labelValue.join(this.split)
        }
      } else {
        return this.placeholder || this.t('uiv.multiSelect.placeholder')
      }
    },
    customOptionsVisible: function customOptionsVisible () {
      return !!this.$slots.option || !!this.$scopedSlots.option
    }
  },
  watch: {
    showDropdown: function showDropdown (v) {
      var this$1 = this;

      // clear filter input when dropdown toggles
      this.filterInput = '';
      this.currentActive = -1;
      this.$emit('visible-change', v);
      if (v && this.filterable && this.filterAutoFocus) {
        this.$nextTick(function () {
          this$1.$refs.filterInput.focus();
        });
      }
    }
  },
  mounted: function mounted () {
    this.els = [this.$el];
  },
  methods: {
    goPrevOption: function goPrevOption () {
      if (!this.showDropdown) {
        return
      }
      this.currentActive > 0 ? this.currentActive-- : this.currentActive = this.flattenGroupedOptions.length - 1;
    },
    goNextOption: function goNextOption () {
      if (!this.showDropdown) {
        return
      }
      this.currentActive < this.flattenGroupedOptions.length - 1 ? this.currentActive++ : this.currentActive = 0;
    },
    selectOption: function selectOption () {
      var index = this.currentActive;
      var options = this.flattenGroupedOptions;
      if (!this.showDropdown) {
        this.showDropdown = true;
      } else if (index >= 0 && index < options.length) {
        this.toggle(options[index]);
      }
    },
    itemClasses: function itemClasses (item) {
      var result = {
        disabled: item.disabled,
        active: this.currentActive === this.flattenGroupedOptions.indexOf(item)
      };
      if (this.itemSelectedClass) {
        result[this.itemSelectedClass] = this.isItemSelected(item);
      }
      return result
    },
    isItemSelected: function isItemSelected (item) {
      return this.value.indexOf(item[this.valueKey]) >= 0
    },
    toggle: function toggle (item) {
      if (item.disabled) {
        return
      }
      var value = item[this.valueKey];
      var index = this.value.indexOf(value);
      if (this.limit === 1) {
        var newValue = index >= 0 ? [] : [value];
        this.$emit('input', newValue);
        this.$emit('change', newValue);
      } else {
        if (index >= 0) {
          var newVal = this.value.slice();
          newVal.splice(index, 1);
          this.$emit('input', newVal);
          this.$emit('change', newVal);
        } else if (this.limit === 0 || this.value.length < this.limit) {
          var newVal$1 = this.value.slice();
          newVal$1.push(value);
          this.$emit('input', newVal$1);
          this.$emit('change', newVal$1);
        } else {
          this.$emit('limit-exceed');
        }
      }
    },
    searchClicked: function searchClicked () {
      this.$emit('search', this.filterInput);
    }
  }
};

/* script */
var __vue_script__$e = script$e;

/* template */
var __vue_render__$e = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "dropdown",
    {
      ref: "dropdown",
      style: _vm.containerStyles,
      attrs: {
        "not-close-elements": _vm.els,
        "append-to-body": _vm.appendToBody,
        disabled: _vm.disabled
      },
      nativeOn: {
        keydown: function($event) {
          if (
            !$event.type.indexOf("key") &&
            _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])
          ) {
            return null
          }
          _vm.showDropdown = false;
        }
      },
      model: {
        value: _vm.showDropdown,
        callback: function($$v) {
          _vm.showDropdown = $$v;
        },
        expression: "showDropdown"
      }
    },
    [
      _c(
        "div",
        {
          staticClass: "form-control dropdown-toggle clearfix",
          class: _vm.selectClasses,
          attrs: {
            disabled: _vm.disabled,
            tabindex: "0",
            "data-role": "trigger"
          },
          on: {
            focus: function($event) {
              return _vm.$emit("focus", $event)
            },
            blur: function($event) {
              return _vm.$emit("blur", $event)
            },
            keydown: [
              function($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "down", 40, $event.key, [
                    "Down",
                    "ArrowDown"
                  ])
                ) {
                  return null
                }
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.goNextOption($event)
              },
              function($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "up", 38, $event.key, [
                    "Up",
                    "ArrowUp"
                  ])
                ) {
                  return null
                }
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.goPrevOption($event)
              },
              function($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                ) {
                  return null
                }
                $event.preventDefault();
                $event.stopPropagation();
                return _vm.selectOption($event)
              }
            ]
          }
        },
        [
          _c(
            "div",
            {
              staticClass: "pull-right",
              staticStyle: {
                display: "inline-block",
                "vertical-align": "middle"
              }
            },
            [
              _c("span", [_vm._v("")]),
              _vm._v(" "),
              _c("span", { staticClass: "caret" })
            ]
          ),
          _vm._v(" "),
          _c("div", {
            class: _vm.selectTextClasses,
            staticStyle: {
              "overflow-x": "hidden",
              "text-overflow": "ellipsis",
              "white-space": "nowrap"
            },
            domProps: { textContent: _vm._s(_vm.selectedText) }
          })
        ]
      ),
      _vm._v(" "),
      _c(
        "template",
        { slot: "dropdown" },
        [
          _vm.filterable
            ? _c("li", { staticStyle: { padding: "4px 8px" } }, [
                _c("input", {
                  directives: [
                    {
                      name: "model",
                      rawName: "v-model",
                      value: _vm.filterInput,
                      expression: "filterInput"
                    }
                  ],
                  ref: "filterInput",
                  staticClass: "form-control input-sm",
                  attrs: {
                    "aria-label": "Filter...",
                    type: "text",
                    placeholder:
                      _vm.filterPlaceholder ||
                      _vm.t("uiv.multiSelect.filterPlaceholder")
                  },
                  domProps: { value: _vm.filterInput },
                  on: {
                    keyup: function($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                      ) {
                        return null
                      }
                      return _vm.searchClicked($event)
                    },
                    keydown: [
                      function($event) {
                        if (
                          !$event.type.indexOf("key") &&
                          _vm._k($event.keyCode, "down", 40, $event.key, [
                            "Down",
                            "ArrowDown"
                          ])
                        ) {
                          return null
                        }
                        $event.preventDefault();
                        $event.stopPropagation();
                        return _vm.goNextOption($event)
                      },
                      function($event) {
                        if (
                          !$event.type.indexOf("key") &&
                          _vm._k($event.keyCode, "up", 38, $event.key, [
                            "Up",
                            "ArrowUp"
                          ])
                        ) {
                          return null
                        }
                        $event.preventDefault();
                        $event.stopPropagation();
                        return _vm.goPrevOption($event)
                      },
                      function($event) {
                        if (
                          !$event.type.indexOf("key") &&
                          _vm._k(
                            $event.keyCode,
                            "enter",
                            13,
                            $event.key,
                            "Enter"
                          )
                        ) {
                          return null
                        }
                        $event.preventDefault();
                        $event.stopPropagation();
                        return _vm.selectOption($event)
                      }
                    ],
                    input: function($event) {
                      if ($event.target.composing) {
                        return
                      }
                      _vm.filterInput = $event.target.value;
                    }
                  }
                })
              ])
            : _vm._e(),
          _vm._v(" "),
          _vm._l(_vm.groupedOptions, function(item) {
            return [
              item.$group
                ? _c("li", {
                    staticClass: "dropdown-header",
                    domProps: { textContent: _vm._s(item.$group) }
                  })
                : _vm._e(),
              _vm._v(" "),
              _vm._l(item.options, function(_item) {
                return [
                  _c(
                    "li",
                    {
                      class: _vm.itemClasses(_item),
                      staticStyle: { outline: "0" },
                      on: {
                        keydown: [
                          function($event) {
                            if (
                              !$event.type.indexOf("key") &&
                              _vm._k($event.keyCode, "down", 40, $event.key, [
                                "Down",
                                "ArrowDown"
                              ])
                            ) {
                              return null
                            }
                            $event.preventDefault();
                            $event.stopPropagation();
                            return _vm.goNextOption($event)
                          },
                          function($event) {
                            if (
                              !$event.type.indexOf("key") &&
                              _vm._k($event.keyCode, "up", 38, $event.key, [
                                "Up",
                                "ArrowUp"
                              ])
                            ) {
                              return null
                            }
                            $event.preventDefault();
                            $event.stopPropagation();
                            return _vm.goPrevOption($event)
                          },
                          function($event) {
                            if (
                              !$event.type.indexOf("key") &&
                              _vm._k(
                                $event.keyCode,
                                "enter",
                                13,
                                $event.key,
                                "Enter"
                              )
                            ) {
                              return null
                            }
                            $event.preventDefault();
                            $event.stopPropagation();
                            return _vm.selectOption($event)
                          }
                        ],
                        click: function($event) {
                          $event.stopPropagation();
                          return _vm.toggle(_item)
                        },
                        mouseenter: function($event) {
                          _vm.currentActive = -1;
                        }
                      }
                    },
                    [
                      _vm.customOptionsVisible
                        ? _c(
                            "a",
                            {
                              staticStyle: { outline: "0" },
                              attrs: { role: "button" }
                            },
                            [
                              _vm._t("option", null, { item: _item }),
                              _vm._v(" "),
                              _vm.selectedIcon && _vm.isItemSelected(_item)
                                ? _c("span", { class: _vm.selectedIconClasses })
                                : _vm._e()
                            ],
                            2
                          )
                        : _vm.isItemSelected(_item)
                        ? _c(
                            "a",
                            {
                              staticStyle: { outline: "0" },
                              attrs: { role: "button" }
                            },
                            [
                              _c("b", [_vm._v(_vm._s(_item[_vm.labelKey]))]),
                              _vm._v(" "),
                              _vm.selectedIcon
                                ? _c("span", { class: _vm.selectedIconClasses })
                                : _vm._e()
                            ]
                          )
                        : _c(
                            "a",
                            {
                              staticStyle: { outline: "0" },
                              attrs: { role: "button" }
                            },
                            [_c("span", [_vm._v(_vm._s(_item[_vm.labelKey]))])]
                          )
                    ]
                  )
                ]
              })
            ]
          })
        ],
        2
      )
    ],
    2
  )
};
var __vue_staticRenderFns__$e = [];
__vue_render__$e._withStripped = true;

  /* style */
  var __vue_inject_styles__$e = undefined;
  /* scoped */
  var __vue_scope_id__$e = undefined;
  /* module identifier */
  var __vue_module_identifier__$e = undefined;
  /* functional template */
  var __vue_is_functional_template__$e = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$e = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
    __vue_inject_styles__$e,
    __vue_script__$e,
    __vue_scope_id__$e,
    __vue_is_functional_template__$e,
    __vue_module_identifier__$e,
    false,
    undefined,
    undefined,
    undefined
  );

var script$f = {
  components: { Collapse: Collapse },
  props: {
    value: Boolean,
    fluid: {
      type: Boolean,
      default: true
    },
    fixedTop: Boolean,
    fixedBottom: Boolean,
    staticTop: Boolean,
    inverse: Boolean
  },
  data: function data () {
    return {
      show: false
    }
  },
  computed: {
    navClasses: function navClasses () {
      return {
        navbar: true,
        'navbar-default': !this.inverse,
        'navbar-inverse': this.inverse,
        'navbar-static-top': this.staticTop,
        'navbar-fixed-bottom': this.fixedBottom,
        'navbar-fixed-top': this.fixedTop
      }
    }
  },
  mounted: function mounted () {
    this.show = !!this.value;
  },
  watch: {
    value: function value (v) {
      this.show = v;
    }
  },
  methods: {
    toggle: function toggle () {
      this.show = !this.show;
      this.$emit('input', this.show);
    }
  }
};

/* script */
var __vue_script__$f = script$f;

/* template */
var __vue_render__$f = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("nav", { class: _vm.navClasses }, [
    _c(
      "div",
      { class: _vm.fluid ? "container-fluid" : "container" },
      [
        _c(
          "div",
          { staticClass: "navbar-header" },
          [
            _vm._t("collapse-btn", [
              _c(
                "button",
                {
                  staticClass: "navbar-toggle collapsed",
                  attrs: { type: "button" },
                  on: { click: _vm.toggle }
                },
                [
                  _c("span", { staticClass: "sr-only" }, [
                    _vm._v("Toggle navigation")
                  ]),
                  _vm._v(" "),
                  _c("span", { staticClass: "icon-bar" }),
                  _vm._v(" "),
                  _c("span", { staticClass: "icon-bar" }),
                  _vm._v(" "),
                  _c("span", { staticClass: "icon-bar" })
                ]
              )
            ]),
            _vm._v(" "),
            _vm._t("brand")
          ],
          2
        ),
        _vm._v(" "),
        _vm._t("default"),
        _vm._v(" "),
        _c(
          "collapse",
          {
            staticClass: "navbar-collapse",
            model: {
              value: _vm.show,
              callback: function($$v) {
                _vm.show = $$v;
              },
              expression: "show"
            }
          },
          [_vm._t("collapse")],
          2
        )
      ],
      2
    )
  ])
};
var __vue_staticRenderFns__$f = [];
__vue_render__$f._withStripped = true;

  /* style */
  var __vue_inject_styles__$f = undefined;
  /* scoped */
  var __vue_scope_id__$f = undefined;
  /* module identifier */
  var __vue_module_identifier__$f = undefined;
  /* functional template */
  var __vue_is_functional_template__$f = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$f = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
    __vue_inject_styles__$f,
    __vue_script__$f,
    __vue_scope_id__$f,
    __vue_is_functional_template__$f,
    __vue_module_identifier__$f,
    false,
    undefined,
    undefined,
    undefined
  );

var NavbarNav = {
  functional: true,
  render: function render (h, ref) {
    var children = ref.children;
    var data = ref.data;
    var props = ref.props;

    return h(
      'ul',
      a(data, {
        class: {
          nav: true,
          'navbar-nav': true,
          'navbar-left': props.left,
          'navbar-right': props.right
        }
      }),
      children
    )
  },
  props: {
    left: Boolean,
    right: Boolean
  }
};

var NavbarForm = {
  functional: true,
  render: function render (h, ref) {
    var children = ref.children;
    var data = ref.data;
    var props = ref.props;

    return h(
      'form',
      a(data, {
        class: {
          'navbar-form': true,
          'navbar-left': props.left,
          'navbar-right': props.right
        }
      }),
      children
    )
  },
  props: {
    left: Boolean,
    right: Boolean
  }
};

var NavbarText = {
  functional: true,
  render: function render (h, ref) {
    var children = ref.children;
    var data = ref.data;
    var props = ref.props;

    return h(
      'p',
      a(data, {
        class: {
          'navbar-text': true,
          'navbar-left': props.left,
          'navbar-right': props.right
        }
      }),
      children
    )
  },
  props: {
    left: Boolean,
    right: Boolean
  }
};

var components = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Carousel: __vue_component__,
  Slide: __vue_component__$1,
  Collapse: Collapse,
  Dropdown: Dropdown,
  Modal: __vue_component__$2,
  Tab: __vue_component__$3,
  Tabs: __vue_component__$4,
  DatePicker: __vue_component__$8,
  Affix: __vue_component__$9,
  Alert: __vue_component__$a,
  Pagination: __vue_component__$b,
  Tooltip: Tooltip,
  Popover: Popover,
  TimePicker: __vue_component__$c,
  Typeahead: __vue_component__$d,
  ProgressBar: ProgressBar,
  ProgressBarStack: ProgressBarStack,
  Breadcrumbs: Breadcrumbs,
  BreadcrumbItem: BreadcrumbItem,
  Btn: Btn,
  BtnGroup: BtnGroup,
  BtnToolbar: BtnToolbar,
  MultiSelect: __vue_component__$e,
  Navbar: __vue_component__$f,
  NavbarNav: NavbarNav,
  NavbarForm: NavbarForm,
  NavbarText: NavbarText
});

var INSTANCE = '_uiv_tooltip_instance';

var bind$1 = function (el, binding) {
  // console.log('bind')
  unbind$1(el);
  var Constructor = Vue.extend(Tooltip);
  var vm = new Constructor({
    propsData: {
      target: el,
      appendTo: binding.arg && '#' + binding.arg,
      text: typeof binding.value === 'string' ? (binding.value && binding.value.toString()) : (binding.value && binding.value.text && binding.value.text.toString()),
      viewport: binding.value && binding.value.viewport && binding.value.viewport.toString(),
      customClass: binding.value && binding.value.customClass && binding.value.customClass.toString(),
      showDelay: binding.value && binding.value.showDelay,
      hideDelay: binding.value && binding.value.hideDelay
    }
  });
  var options = [];
  for (var key in binding.modifiers) {
    if (hasOwnProperty(binding.modifiers, key) && binding.modifiers[key]) {
      options.push(key);
    }
  }
  options.forEach(function (option) {
    if (/(top)|(left)|(right)|(bottom)/.test(option)) {
      vm.placement = option;
    } else if (/(hover)|(focus)|(click)/.test(option)) {
      vm.trigger = option;
    } else if (/unenterable/.test(option)) {
      vm.enterable = false;
    }
  });
  vm.$mount();
  el[INSTANCE] = vm;
};

var unbind$1 = function (el) {
  // console.log('unbind')
  var vm = el[INSTANCE];
  if (vm) {
    vm.$destroy();
  }
  delete el[INSTANCE];
};

var update$1 = function (el, binding) {
  // console.log('update')
  if (binding.value !== binding.oldValue) {
    bind$1(el, binding);
  }
};

var tooltip = { bind: bind$1, unbind: unbind$1, update: update$1 };

var INSTANCE$1 = '_uiv_popover_instance';

var bind$2 = function (el, binding) {
  // console.log('bind')
  unbind$2(el);
  var Constructor = Vue.extend(Popover);
  var vm = new Constructor({
    propsData: {
      target: el,
      appendTo: binding.arg && '#' + binding.arg,
      title: binding.value && binding.value.title && binding.value.title.toString(),
      content: binding.value && binding.value.content && binding.value.content.toString(),
      viewport: binding.value && binding.value.viewport && binding.value.viewport.toString(),
      customClass: binding.value && binding.value.customClass && binding.value.customClass.toString()
    }
  });
  var options = [];
  for (var key in binding.modifiers) {
    if (hasOwnProperty(binding.modifiers, key) && binding.modifiers[key]) {
      options.push(key);
    }
  }
  options.forEach(function (option) {
    if (/(top)|(left)|(right)|(bottom)/.test(option)) {
      vm.placement = option;
    } else if (/(hover)|(focus)|(click)/.test(option)) {
      vm.trigger = option;
    } else if (/unenterable/.test(option)) {
      vm.enterable = false;
    }
  });
  vm.$mount();
  el[INSTANCE$1] = vm;
};

var unbind$2 = function (el) {
  // console.log('unbind')
  var vm = el[INSTANCE$1];
  if (vm) {
    vm.$destroy();
  }
  delete el[INSTANCE$1];
};

var update$2 = function (el, binding) {
  // console.log('update')
  if (binding.value !== binding.oldValue) {
    bind$2(el, binding);
  }
};

var popover = { bind: bind$2, unbind: unbind$2, update: update$2 };

function ScrollSpy (element, target, options) {
  if ( target === void 0 ) target = 'body';
  if ( options === void 0 ) options = {};

  this.el = element;
  this.opts = assign({}, ScrollSpy.DEFAULTS, options);
  this.opts.target = target;
  if (target === 'body') {
    this.scrollElement = window;
  } else {
    this.scrollElement = document.querySelector(("[id=" + target + "]"));
  }
  this.selector = 'li > a';
  this.offsets = [];
  this.targets = [];
  this.activeTarget = null;
  this.scrollHeight = 0;
  if (this.scrollElement) {
    this.refresh();
    this.process();
  }
}

ScrollSpy.DEFAULTS = {
  offset: 10,
  callback: function (ele) { return 0; }
};

ScrollSpy.prototype.getScrollHeight = function () {
  return this.scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
};

ScrollSpy.prototype.refresh = function () {
  var this$1 = this;

  this.offsets = [];
  this.targets = [];
  this.scrollHeight = this.getScrollHeight();
  var list = nodeListToArray(this.el.querySelectorAll(this.selector));
  var isWindow = this.scrollElement === window;
  list
    .map(function (ele) {
      var href = ele.getAttribute('href');
      if (/^#./.test(href)) {
        var rootEl = isWindow ? document : this$1.scrollElement;
        var hrefEl = rootEl.querySelector(("[id='" + (href.slice(1)) + "']"));
        var offset = isWindow ? hrefEl.getBoundingClientRect().top : hrefEl.offsetTop;
        return [offset, href]
      } else {
        return null
      }
    })
    .filter(function (item) { return item; })
    .sort(function (a, b) { return a[0] - b[0]; })
    .forEach(function (item) {
      this$1.offsets.push(item[0]);
      this$1.targets.push(item[1]);
    });
  // console.log(this.offsets, this.targets)
};

ScrollSpy.prototype.process = function () {
  var isWindow = this.scrollElement === window;
  var scrollTop = (isWindow ? window.pageYOffset : this.scrollElement.scrollTop) + this.opts.offset;
  var scrollHeight = this.getScrollHeight();
  var scrollElementHeight = isWindow ? getViewportSize().height : this.scrollElement.getBoundingClientRect().height;
  var maxScroll = this.opts.offset + scrollHeight - scrollElementHeight;
  var offsets = this.offsets;
  var targets = this.targets;
  var activeTarget = this.activeTarget;
  var i;
  if (this.scrollHeight !== scrollHeight) {
    this.refresh();
  }
  if (scrollTop >= maxScroll) {
    return activeTarget !== (i = targets[targets.length - 1]) && this.activate(i)
  }
  if (activeTarget && scrollTop < offsets[0]) {
    this.activeTarget = null;
    return this.clear()
  }
  for (i = offsets.length; i--;) {
    activeTarget !== targets[i] &&
    scrollTop >= offsets[i] &&
    (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) &&
    this.activate(targets[i]);
  }
};

ScrollSpy.prototype.activate = function (target) {
  this.activeTarget = target;
  this.clear();
  var selector = this.selector +
    '[data-target="' + target + '"],' +
    this.selector + '[href="' + target + '"]';
  var activeCallback = this.opts.callback;
  var active = nodeListToArray(this.el.querySelectorAll(selector));
  active.forEach(function (ele) {
    getParents(ele, 'li')
      .forEach(function (item) {
        addClass(item, 'active');
        activeCallback(item);
      });
    if (getParents(ele, '.dropdown-menu').length) {
      addClass(getClosest(ele, 'li.dropdown'), 'active');
    }
  });
};

ScrollSpy.prototype.clear = function () {
  var this$1 = this;

  var list = nodeListToArray(this.el.querySelectorAll(this.selector));
  list.forEach(function (ele) {
    getParents(ele, '.active', this$1.opts.target).forEach(function (item) {
      removeClass(item, 'active');
    });
  });
};

var INSTANCE$2 = '_uiv_scrollspy_instance';
var events$1 = [EVENTS.RESIZE, EVENTS.SCROLL];

var bind$3 = function (el, binding) {
  // console.log('bind')
  unbind$3(el);
};

var inserted = function (el, binding) {
  // console.log('inserted')
  var scrollSpy = new ScrollSpy(el, binding.arg, binding.value);
  if (scrollSpy.scrollElement) {
    scrollSpy.handler = function () {
      scrollSpy.process();
    };
    events$1.forEach(function (event) {
      on(scrollSpy.scrollElement, event, scrollSpy.handler);
    });
  }
  el[INSTANCE$2] = scrollSpy;
};

var unbind$3 = function (el) {
  // console.log('unbind')
  var instance = el[INSTANCE$2];
  if (instance && instance.scrollElement) {
    events$1.forEach(function (event) {
      off(instance.scrollElement, event, instance.handler);
    });
    delete el[INSTANCE$2];
  }
};

var update$3 = function (el, binding) {
  // console.log('update')
  var isArgUpdated = binding.arg !== binding.oldArg;
  var isValueUpdated = binding.value !== binding.oldValue;
  if (isArgUpdated || isValueUpdated) {
    bind$3(el);
    inserted(el, binding);
  }
};

var scrollspy = { bind: bind$3, unbind: unbind$3, update: update$3, inserted: inserted };

var directives = /*#__PURE__*/Object.freeze({
  __proto__: null,
  tooltip: tooltip,
  popover: popover,
  scrollspy: scrollspy
});

var TYPES = {
  ALERT: 0,
  CONFIRM: 1,
  PROMPT: 2
};

var script$g = {
  mixins: [Local],
  components: { Modal: __vue_component__$2, Btn: Btn },
  props: {
    backdrop: null,
    title: String,
    content: String,
    html: {
      type: Boolean,
      default: false
    },
    okText: String,
    okType: {
      type: String,
      default: 'primary'
    },
    cancelText: String,
    cancelType: {
      type: String,
      default: 'default'
    },
    type: {
      type: Number,
      default: TYPES.ALERT
    },
    size: {
      type: String,
      default: 'sm'
    },
    cb: {
      type: Function,
      required: true
    },
    validator: {
      type: Function,
      default: function () { return null; }
    },
    customClass: null,
    defaultValue: String,
    inputType: {
      type: String,
      default: 'text'
    },
    autoFocus: {
      type: String,
      default: 'ok'
    },
    reverseButtons: {
      type: Boolean,
      default: false
    }
  },
  data: function data () {
    return {
      TYPES: TYPES,
      show: false,
      input: '',
      dirty: false
    }
  },
  mounted: function mounted () {
    if (this.defaultValue) {
      this.input = this.defaultValue;
    }
  },
  computed: {
    closeOnBackdropClick: function closeOnBackdropClick () {
      // use backdrop prop if exist
      // otherwise, only not available if render as alert
      return isExist(this.backdrop) ? Boolean(this.backdrop) : (this.type !== TYPES.ALERT)
    },
    inputError: function inputError () {
      return this.validator(this.input)
    },
    inputNotValid: function inputNotValid () {
      return this.dirty && this.inputError
    },
    okBtnText: function okBtnText () {
      return this.okText || this.t('uiv.modal.ok')
    },
    cancelBtnText: function cancelBtnText () {
      return this.cancelText || this.t('uiv.modal.cancel')
    }
  },
  methods: {
    toggle: function toggle (show, msg) {
      this.$refs.modal.toggle(show, msg);
    },
    validate: function validate () {
      this.dirty = true;
      if (!isExist(this.inputError)) {
        this.toggle(false, { value: this.input });
      }
    }
  }
};

/* script */
var __vue_script__$g = script$g;

/* template */
var __vue_render__$g = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "modal",
    {
      ref: "modal",
      class: _vm.customClass,
      attrs: {
        "auto-focus": "",
        size: _vm.size,
        title: _vm.title,
        header: !!_vm.title,
        backdrop: _vm.closeOnBackdropClick,
        "cancel-text": _vm.cancelText,
        "ok-text": _vm.okText
      },
      on: { hide: _vm.cb },
      model: {
        value: _vm.show,
        callback: function($$v) {
          _vm.show = $$v;
        },
        expression: "show"
      }
    },
    [
      _vm.html
        ? _c("div", { domProps: { innerHTML: _vm._s(_vm.content) } })
        : _c("p", [_vm._v(_vm._s(_vm.content))]),
      _vm._v(" "),
      _vm.type === _vm.TYPES.PROMPT
        ? _c("div", [
            _c(
              "div",
              {
                staticClass: "form-group",
                class: { "has-error": _vm.inputNotValid }
              },
              [
                _vm.inputType === "checkbox"
                  ? _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.input,
                          expression: "input"
                        }
                      ],
                      ref: "input",
                      staticClass: "form-control",
                      attrs: {
                        required: "",
                        "data-action": "auto-focus",
                        type: "checkbox"
                      },
                      domProps: {
                        checked: Array.isArray(_vm.input)
                          ? _vm._i(_vm.input, null) > -1
                          : _vm.input
                      },
                      on: {
                        change: [
                          function($event) {
                            var $$a = _vm.input,
                              $$el = $event.target,
                              $$c = $$el.checked ? true : false;
                            if (Array.isArray($$a)) {
                              var $$v = null,
                                $$i = _vm._i($$a, $$v);
                              if ($$el.checked) {
                                $$i < 0 && (_vm.input = $$a.concat([$$v]));
                              } else {
                                $$i > -1 &&
                                  (_vm.input = $$a
                                    .slice(0, $$i)
                                    .concat($$a.slice($$i + 1)));
                              }
                            } else {
                              _vm.input = $$c;
                            }
                          },
                          function($event) {
                            _vm.dirty = true;
                          }
                        ],
                        keyup: function($event) {
                          if (
                            !$event.type.indexOf("key") &&
                            _vm._k(
                              $event.keyCode,
                              "enter",
                              13,
                              $event.key,
                              "Enter"
                            )
                          ) {
                            return null
                          }
                          return _vm.validate($event)
                        }
                      }
                    })
                  : _vm.inputType === "radio"
                  ? _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.input,
                          expression: "input"
                        }
                      ],
                      ref: "input",
                      staticClass: "form-control",
                      attrs: {
                        required: "",
                        "data-action": "auto-focus",
                        type: "radio"
                      },
                      domProps: { checked: _vm._q(_vm.input, null) },
                      on: {
                        change: [
                          function($event) {
                            _vm.input = null;
                          },
                          function($event) {
                            _vm.dirty = true;
                          }
                        ],
                        keyup: function($event) {
                          if (
                            !$event.type.indexOf("key") &&
                            _vm._k(
                              $event.keyCode,
                              "enter",
                              13,
                              $event.key,
                              "Enter"
                            )
                          ) {
                            return null
                          }
                          return _vm.validate($event)
                        }
                      }
                    })
                  : _c("input", {
                      directives: [
                        {
                          name: "model",
                          rawName: "v-model",
                          value: _vm.input,
                          expression: "input"
                        }
                      ],
                      ref: "input",
                      staticClass: "form-control",
                      attrs: {
                        required: "",
                        "data-action": "auto-focus",
                        type: _vm.inputType
                      },
                      domProps: { value: _vm.input },
                      on: {
                        change: function($event) {
                          _vm.dirty = true;
                        },
                        keyup: function($event) {
                          if (
                            !$event.type.indexOf("key") &&
                            _vm._k(
                              $event.keyCode,
                              "enter",
                              13,
                              $event.key,
                              "Enter"
                            )
                          ) {
                            return null
                          }
                          return _vm.validate($event)
                        },
                        input: function($event) {
                          if ($event.target.composing) {
                            return
                          }
                          _vm.input = $event.target.value;
                        }
                      }
                    }),
                _vm._v(" "),
                _c(
                  "span",
                  {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: _vm.inputNotValid,
                        expression: "inputNotValid"
                      }
                    ],
                    staticClass: "help-block"
                  },
                  [_vm._v(_vm._s(_vm.inputError))]
                )
              ]
            )
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.type === _vm.TYPES.ALERT
        ? _c(
            "template",
            { slot: "footer" },
            [
              _c("btn", {
                attrs: {
                  type: _vm.okType,
                  "data-action": _vm.autoFocus === "ok" ? "auto-focus" : ""
                },
                domProps: { textContent: _vm._s(_vm.okBtnText) },
                on: {
                  click: function($event) {
                    return _vm.toggle(false, "ok")
                  }
                }
              })
            ],
            1
          )
        : _c(
            "template",
            { slot: "footer" },
            [
              _vm.reverseButtons
                ? [
                    _vm.type === _vm.TYPES.CONFIRM
                      ? _c("btn", {
                          attrs: {
                            type: _vm.okType,
                            "data-action":
                              _vm.autoFocus === "ok" ? "auto-focus" : ""
                          },
                          domProps: { textContent: _vm._s(_vm.okBtnText) },
                          on: {
                            click: function($event) {
                              return _vm.toggle(false, "ok")
                            }
                          }
                        })
                      : _c("btn", {
                          attrs: { type: _vm.okType },
                          domProps: { textContent: _vm._s(_vm.okBtnText) },
                          on: { click: _vm.validate }
                        }),
                    _vm._v(" "),
                    _c("btn", {
                      attrs: {
                        type: _vm.cancelType,
                        "data-action":
                          _vm.autoFocus === "cancel" ? "auto-focus" : ""
                      },
                      domProps: { textContent: _vm._s(_vm.cancelBtnText) },
                      on: {
                        click: function($event) {
                          return _vm.toggle(false, "cancel")
                        }
                      }
                    })
                  ]
                : [
                    _c("btn", {
                      attrs: {
                        type: _vm.cancelType,
                        "data-action":
                          _vm.autoFocus === "cancel" ? "auto-focus" : ""
                      },
                      domProps: { textContent: _vm._s(_vm.cancelBtnText) },
                      on: {
                        click: function($event) {
                          return _vm.toggle(false, "cancel")
                        }
                      }
                    }),
                    _vm._v(" "),
                    _vm.type === _vm.TYPES.CONFIRM
                      ? _c("btn", {
                          attrs: {
                            type: _vm.okType,
                            "data-action":
                              _vm.autoFocus === "ok" ? "auto-focus" : ""
                          },
                          domProps: { textContent: _vm._s(_vm.okBtnText) },
                          on: {
                            click: function($event) {
                              return _vm.toggle(false, "ok")
                            }
                          }
                        })
                      : _c("btn", {
                          attrs: { type: _vm.okType },
                          domProps: { textContent: _vm._s(_vm.okBtnText) },
                          on: { click: _vm.validate }
                        })
                  ]
            ],
            2
          )
    ],
    2
  )
};
var __vue_staticRenderFns__$g = [];
__vue_render__$g._withStripped = true;

  /* style */
  var __vue_inject_styles__$g = undefined;
  /* scoped */
  var __vue_scope_id__$g = undefined;
  /* module identifier */
  var __vue_module_identifier__$g = undefined;
  /* functional template */
  var __vue_is_functional_template__$g = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$g = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
    __vue_inject_styles__$g,
    __vue_script__$g,
    __vue_scope_id__$g,
    __vue_is_functional_template__$g,
    __vue_module_identifier__$g,
    false,
    undefined,
    undefined,
    undefined
  );

var queue = [];

var destroy = function (instance) {
  // console.log('destroyModal')
  removeFromDom(instance.$el);
  instance.$destroy();
  spliceIfExist(queue, instance);
};

// handel cancel or ok for confirm & prompt
var shallResolve = function (type, msg) {
  if (type === TYPES.CONFIRM) {
    // is confirm
    return msg === 'ok'
  } else {
    // is prompt
    return isExist(msg) && isString(msg.value)
  }
};

var init = function (type, options, cb, resolve, reject) {
  if ( resolve === void 0 ) resolve = null;
  if ( reject === void 0 ) reject = null;

  var i18n = this.$i18n;
  var instance = new Vue({
    extends: __vue_component__$g,
    i18n: i18n,
    propsData: assign({}, { type: type }, options, {
      cb: function cb$1 (msg) {
        destroy(instance);
        if (isFunction(cb)) {
          if (type === TYPES.CONFIRM) {
            shallResolve(type, msg) ? cb(null, msg) : cb(msg);
          } else if (type === TYPES.PROMPT) {
            shallResolve(type, msg) ? cb(null, msg.value) : cb(msg);
          } else {
            cb(msg);
          }
        } else if (resolve && reject) {
          if (type === TYPES.CONFIRM) {
            shallResolve(type, msg) ? resolve(msg) : reject(msg);
          } else if (type === TYPES.PROMPT) {
            shallResolve(type, msg) ? resolve(msg.value) : reject(msg);
          } else {
            resolve(msg);
          }
        }
      }
    })
  });
  instance.$mount();
  document.body.appendChild(instance.$el);
  instance.show = true;
  queue.push(instance);
};

// eslint-disable-next-line default-param-last
var initModal = function (type, options, cb) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  if (isPromiseSupported()) {
    return new Promise(function (resolve, reject) {
      init.apply(this$1, [type, options, cb, resolve, reject]);
    })
  } else {
    init.apply(this, [type, options, cb]);
  }
};

var alert = function (options, cb) {
  return initModal.apply(this, [TYPES.ALERT, options, cb])
};

var confirm = function (options, cb) {
  return initModal.apply(this, [TYPES.CONFIRM, options, cb])
};

var prompt = function (options, cb) {
  return initModal.apply(this, [TYPES.PROMPT, options, cb])
};

var MessageBox = { alert: alert, confirm: confirm, prompt: prompt };

var TYPES$1 = {
  SUCCESS: 'success',
  INFO: 'info',
  DANGER: 'danger',
  WARNING: 'warning'
};

var PLACEMENTS$1 = {
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right'
};

var IN_CLASS$1 = 'in';
var ICON = 'glyphicon';
var WIDTH = 300;
var TRANSITION_DURATION = 300;

var script$h = {
  components: { Alert: __vue_component__$a },
  props: {
    title: String,
    content: String,
    html: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 5000
    },
    dismissible: {
      type: Boolean,
      default: true
    },
    type: String,
    placement: String,
    icon: String,
    customClass: null,
    cb: {
      type: Function,
      required: true
    },
    queue: {
      type: Array,
      required: true
    },
    offsetY: {
      type: Number,
      default: 15
    },
    offsetX: {
      type: Number,
      default: 15
    },
    offset: {
      type: Number,
      default: 15
    }
  },
  data: function data () {
    return {
      height: 0,
      top: 0,
      horizontal: this.placement === PLACEMENTS$1.TOP_LEFT || this.placement === PLACEMENTS$1.BOTTOM_LEFT ? 'left' : 'right',
      vertical: this.placement === PLACEMENTS$1.TOP_LEFT || this.placement === PLACEMENTS$1.TOP_RIGHT ? 'top' : 'bottom'
    }
  },
  created: function created () {
    // get prev notifications total height in the queue
    this.top = this.getTotalHeightOfQueue(this.queue);
  },
  mounted: function mounted () {
    var this$1 = this;

    var el = this.$el;
    el.style[this.vertical] = this.top + 'px';
    this.$nextTick(function () {
      el.style[this$1.horizontal] = "-" + WIDTH + "px";
      this$1.height = el.offsetHeight;
      el.style[this$1.horizontal] = (this$1.offsetX) + "px";
      addClass(el, IN_CLASS$1);
    });
  },
  computed: {
    styles: function styles () {
      var obj;

      var queue = this.queue;
      var thisIndex = queue.indexOf(this);
      return ( obj = {
        position: 'fixed'
      }, obj[this.vertical] = ((this.getTotalHeightOfQueue(queue, thisIndex)) + "px"), obj.width = (WIDTH + "px"), obj.transition = ("all " + (TRANSITION_DURATION / 1000) + "s ease-in-out"), obj )
    },
    icons: function icons () {
      if (isString(this.icon)) {
        return this.icon
      }
      switch (this.type) {
        case TYPES$1.INFO:
        case TYPES$1.WARNING:
          return (ICON + " " + ICON + "-info-sign")
        case TYPES$1.SUCCESS:
          return (ICON + " " + ICON + "-ok-sign")
        case TYPES$1.DANGER:
          return (ICON + " " + ICON + "-remove-sign")
        default:
          return null
      }
    }
  },
  methods: {
    getTotalHeightOfQueue: function getTotalHeightOfQueue (queue, lastIndex) {
      if ( lastIndex === void 0 ) lastIndex = queue.length;

      var totalHeight = this.offsetY;
      for (var i = 0; i < lastIndex; i++) {
        totalHeight += queue[i].height + this.offset;
      }
      return totalHeight
    },
    onDismissed: function onDismissed () {
      removeClass(this.$el, IN_CLASS$1);
      setTimeout(this.cb, TRANSITION_DURATION);
    }
  }
};

/* script */
var __vue_script__$h = script$h;

/* template */
var __vue_render__$h = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c(
    "alert",
    {
      staticClass: "fade",
      class: _vm.customClass,
      style: _vm.styles,
      attrs: {
        type: _vm.type,
        duration: _vm.duration,
        dismissible: _vm.dismissible
      },
      on: { dismissed: _vm.onDismissed }
    },
    [
      _c("div", { staticClass: "media", staticStyle: { margin: "0" } }, [
        _vm.icons
          ? _c("div", { staticClass: "media-left" }, [
              _c("span", {
                class: _vm.icons,
                staticStyle: { "font-size": "1.5em" }
              })
            ])
          : _vm._e(),
        _vm._v(" "),
        _c("div", { staticClass: "media-body" }, [
          _vm.title
            ? _c("div", { staticClass: "media-heading" }, [
                _c("b", [_vm._v(_vm._s(_vm.title))])
              ])
            : _vm._e(),
          _vm._v(" "),
          _vm.html
            ? _c("div", { domProps: { innerHTML: _vm._s(_vm.content) } })
            : _c("div", [_vm._v(_vm._s(_vm.content))])
        ])
      ])
    ]
  )
};
var __vue_staticRenderFns__$h = [];
__vue_render__$h._withStripped = true;

  /* style */
  var __vue_inject_styles__$h = undefined;
  /* scoped */
  var __vue_scope_id__$h = undefined;
  /* module identifier */
  var __vue_module_identifier__$h = undefined;
  /* functional template */
  var __vue_is_functional_template__$h = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  var __vue_component__$h = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
    __vue_inject_styles__$h,
    __vue_script__$h,
    __vue_scope_id__$h,
    __vue_is_functional_template__$h,
    __vue_module_identifier__$h,
    false,
    undefined,
    undefined,
    undefined
  );

var queues = {};
queues[PLACEMENTS$1.TOP_LEFT] = [];
queues[PLACEMENTS$1.TOP_RIGHT] = [];
queues[PLACEMENTS$1.BOTTOM_LEFT] = [];
queues[PLACEMENTS$1.BOTTOM_RIGHT] = [];

var destroy$1 = function (queue, instance) {
  // console.log('destroyNotification')
  removeFromDom(instance.$el);
  instance.$destroy();
  spliceIfExist(queue, instance);
};

var init$1 = function (options, cb, resolve, reject) {
  if ( resolve === void 0 ) resolve = null;
  if ( reject === void 0 ) reject = null;

  var placement = options.placement;
  var queue = queues[placement];
  // check if placement is valid
  if (!isExist(queue)) {
    return
  }
  /* istanbul ignore else */
  // `error` alias of `danger`
  if (options.type === 'error') {
    options.type = 'danger';
  }
  var instance = new Vue({
    extends: __vue_component__$h,
    propsData: assign({}, { queue: queue, placement: placement }, options, {
      cb: function cb$1 (msg) {
        destroy$1(queue, instance);
        if (isFunction(cb)) {
          cb(msg);
        } else if (resolve && reject) {
          resolve(msg);
        }
      }
    })
  });
  instance.$mount();
  document.body.appendChild(instance.$el);
  queue.push(instance);
};

// eslint-disable-next-line default-param-last
var _notify = function (options, cb) {
  if ( options === void 0 ) options = {};

  // simplify usage: pass string as option.content
  if (isString(options)) {
    options = {
      content: options
    };
  }
  // set default placement as top-right
  if (!isExist(options.placement)) {
    options.placement = PLACEMENTS$1.TOP_RIGHT;
  }
  if (isPromiseSupported()) {
    return new Promise(function (resolve, reject) {
      init$1(options, cb, resolve, reject);
    })
  } else {
    init$1(options, cb);
  }
};

function _notify2 (type, args) {
  if (isString(args)) {
    _notify({
      content: args,
      type: type
    });
  } else {
    _notify(assign({}, args, {
      type: type
    }));
  }
}

var notify = Object.defineProperties(_notify, {
  success: {
    configurable: false,
    writable: false,
    value: function value (args) {
      _notify2('success', args);
    }
  },
  info: {
    configurable: false,
    writable: false,
    value: function value (args) {
      _notify2('info', args);
    }
  },
  warning: {
    configurable: false,
    writable: false,
    value: function value (args) {
      _notify2('warning', args);
    }
  },
  danger: {
    configurable: false,
    writable: false,
    value: function value (args) {
      _notify2('danger', args);
    }
  },
  error: {
    configurable: false,
    writable: false,
    value: function value (args) {
      _notify2('danger', args);
    }
  },
  dismissAll: {
    configurable: false,
    writable: false,
    value: function value () {
      for (var key in queues) {
        /* istanbul ignore else */
        if (hasOwnProperty(queues, key)) {
          queues[key].forEach(function (instance) {
            instance.onDismissed();
          });
        }
      }
    }
  }
});

var Notification = { notify: notify };

var services = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MessageBox: MessageBox,
  Notification: Notification
});

var install = function (Vue, options) {
  if ( options === void 0 ) options = {};

  // Setup language, en-US for default
  locale.use(options.locale);
  locale.i18n(options.i18n);
  // Register components
  Object.keys(components).forEach(function (key) {
    var _key = options.prefix ? options.prefix + key : key;
    Vue.component(_key, components[key]);
  });
  // Register directives
  Object.keys(directives).forEach(function (key) {
    var _key = options.prefix ? options.prefix + '-' + key : key;
    Vue.directive(_key, directives[key]);
  });
  // Register services
  Object.keys(services).forEach(function (key) {
    var service = services[key];
    Object.keys(service).forEach(function (serviceKey) {
      var _key = options.prefix ? options.prefix + '_' + serviceKey : serviceKey;
      Vue.prototype['$' + _key] = service[serviceKey];
    });
  });
};

export { __vue_component__$9 as Affix, __vue_component__$a as Alert, BreadcrumbItem, Breadcrumbs, Btn, BtnGroup, BtnToolbar, __vue_component__ as Carousel, Collapse, __vue_component__$8 as DatePicker, Dropdown, MessageBox, __vue_component__$2 as Modal, __vue_component__$e as MultiSelect, __vue_component__$f as Navbar, NavbarForm, NavbarNav, NavbarText, Notification, __vue_component__$b as Pagination, Popover, ProgressBar, ProgressBarStack, __vue_component__$1 as Slide, __vue_component__$3 as Tab, __vue_component__$4 as Tabs, __vue_component__$c as TimePicker, Tooltip, __vue_component__$d as Typeahead, install, popover, scrollspy, tooltip };
//# sourceMappingURL=uiv.esm.js.map
